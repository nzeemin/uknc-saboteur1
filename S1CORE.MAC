	.TITLE	S1CORE
	.ASECT

; Special comments-warnings in the code:
; !!MUT-CMD!! - the command mutable, means other code changes it
; !!MUT-ARG!! - the command argument is mutable

;------------------------------------------------------------------------------

.MACRO	PUSH	RR
	MOV	RR, -(SP)
.ENDM
.MACRO	POP	RR
	MOV	(SP)+, RR
.ENDM

;------------------------------------------------------------------------------

SCREEN = 100000		; Начало экрана, косвенный адрес для УКНЦ
SCRTOP = SCREEN + 4	; Where the game scren starts
SCRIND = SCRTOP + <1200*19.>	; Screen address for first indicators line

TIMERI = 200.		; Fast timer reset value, see LB5C4

;------------------------------------------------------------------------------

	.=001000
STCORE::
K01000:
	CLR	@#177560
	MTPS	#000340			; Disable interrupts
	MOV	SP, OSTACK		; Сохраняем начальное значение SP
	MOV	#1000, SP
;	CALL	STPAL			; Установить игровую палитру
	MOV	#GAMESC, R1		; Строка для подготовки игрового экрана
	CALL	PRINT
	CALL	PAUSE			; подождём пока очистится экран
K01220:	BR	START
;
OSTACK:	.WORD	01000			; Сохраняем начальное значение SP
;
FNCORE:
	MOV	OSTACK, SP
	MOV	#EXITSC, R1		; Строка очистки экрана перед выходом
	CALL	PRINT
	EMT	350			; .EXIT
;
;------------------------------------------------------------------------------

; Подпрограмма: Печать строки: R1 = адрес строки, строка завершается 0; портит R0
PRINT:
10$:	MOVB	(R1)+, R0	; Конец строки?
	BEQ	RETN		; да => выходим
20$:	TSTB	@#177564	; Источник канала 0 готов?
	BPL	20$		; нет => ждём
	MOV	R0, @#177566	; передаём символ в канал 0
	BR	10$

; Подпрограмма: пауза после очистки экрана чтобы ПП закончил работу
PAUSE:	; Pause to let PPU finish the previous commands
	MOV	#177777, R5
1$:	NOP
	SOB	R5, 1$
RETN:	RETURN

; Подпрограмма: Ожидание символа с клавиатуры: R0 = полученный символ
WTKEY:	TSTB	@#177560
	BPL	WTKEY
	CLR	R0
	MOVB	@#177562, R0	; символ в R0
	CMPB	R0, #33
	BNE	RETN
ESCKEY:	TSTB	@#177560
	BPL	ESCKEY
	MOVB	@#177562, R0	; символ в R0
	BIS	#15400,R0	; #33 в верхний байт
	RETURN
; Подпрограмма: Получение символа с клавиатуры: флаг Z=0 = есть символ, R0 = полученный символ
GETKEY:	TSTB	@#177560	; есть символ?
	BPL	10$		; нет символа => выходим
	MOVB	@#177562, R0	; символ в R0
	CMPB	R0, #33		; Esc ?
	BEQ	ESCKEY
	RETURN
10$:	CLR	R0		; возвращаем пустой код клавиши
	RETURN

GAMESC:	; Строка подготовки игрового экрана
	.BYTE	33,246,62	; Формат экрана 40x24
	.BYTE	33,240,63	; Цвет символа
	.BYTE	33,241,60	; Цвет знакоместа 0
	.BYTE	33,242,60	; Цвет фона 0
	.BYTE	14		; Clear screen
	.BYTE	33,247,60	; Цвет курсора
	.BYTE	033,131,61,40	; Курсор в позицию
	.BYTE	0
EXITSC:	; Строка очистки экрана перед выходом
	.BYTE	33,246,061	; Формат экрана 80x24
	.BYTE	33,240,67	; Цвет символа
	.BYTE	33,241,61	; Цвет знакоместа 1
	.BYTE	33,242,61	; Цвет фона 1
	.BYTE	33,247,67	; Цвет курсора
	.BYTE	14		; Очистить экран
	.BYTE	0

	.EVEN

;------------------------------------------------------------------------------

PALNO:	.WORD	0		; Номер текущей палитры
; Палитра для установки в памяти ПП
;		 |____....____....|
PALETD:	.WORD	^B1011101010011000	; Палитра УКНЦ по умолчанию
	.WORD	^B1111111011011100	;
PALETT:	.WORD	^B1011111110010000	; Игровая палитра 0
	.WORD	^B1111110011011110	;   белый на чёрном
	.WORD	^B1011110010011000	; Игровая палитра 1
	.WORD	^B1111111111011110	;   зелёный на чёрном
	.WORD	^B1011111110011001	; Игровая палитра 2
	.WORD	^B1111111111011100	;   чёрный на синем
	.WORD	^B0100000001101111	; Игровая палитра 3
	.WORD	^B0000001100100001	;   чёрный на белом

; Массив параметров для обмена с ПП по каналу 2
PPBLCK:	.BYTE	0		; В этом байте будет содержаться код ошибки или 0
PPBCMD:	.BYTE	20		; Команда (01-ВЫДЕЛИТЬ ПАМЯТЬ, 02-ОСВОБОДИТЬ ПАМЯТЬ 10-ЧТЕНИЕ, 20-ЗАПИСЬ, 30-ПУСК)
	.WORD	32		; Устройство - периферийный процессор
PPBAPP:	.WORD	002470		; Адрес ОЗУ ПП - два слова палитры
PPBACP:	.WORD	PALETT		; Адрес ОЗУ ЦП - адрес новой палитры
	.WORD	2		; Длина блока в словах
PPBADR:	.WORD	PPBLCK		; Слово всегда содержит начальный адрес массива параметров
	.WORD	401		; Стоповый элемент (используется при передаче)

; Вернуть стандартную палитру
STPALD:
	MOV	#PALETD, R0
	BR	STPAL1
; Установить текущую палитру
STPAL:
	MOV	@#PALNO, R0
	BIC	#177774, R0	; 0..3
	ASL	R0
	ASL	R0		; x4
	ADD	#PALETT, R0
STPAL1:	MOV	R0, @#PPBACP
;	BR	PPSEND
; Подпрограмма передачи по каналу К2 массива параметров в ПП
PPSEND:	MOV	#PPBADR, R0
	MOV	#5, R1
	MTPS	#200
	BR	1$
2$:	MOVB	(R0)+, @#176676
1$:	TSTB	@#176674
	BPL	1$
	SOB	R1, 2$
	MTPS	#0
	RETURN

;------------------------------------------------------------------------------
;
START:
	JMP	LBC0D			; Title picture and music, then go to Main menu

;	CALL	LACCA			; Frames/indicators
;	JMP	LB66A			; Current Room changed, entering the new Room

;100$:	BR	100$	;DEADLOOP
;	HALT

;	RETURN ;STUB

;------------------------------------------------------------------------------

.INCLUDE /S1ROOM.MAC/

.INCLUDE /S1FONT.MAC/

;------------------------------------------------------------------------------

; Show title picture (two ninjas)
L6289:	MOV	#L62DB, R3		; Encoded picture data address
	MOV	#L6590, R2		; Tile screens address, used as a buffer
L628F:	MOVB	(R3)+, R0		; Load next byte of picture data
	BEQ	L62A1			; $00 => repeat byte N times
	CMPB	R0, #2			; check for control byte $02 - end of sequence
	BEQ	L62A9			; => Copy the buffer to screen
	CMPB	R0, #377		; check for block marker
	BEQ	L62A1			; => repeat byte N times
	MOVB	R0, (R2)+		; Store regular byte into tile screen
	BR	L628F			; Loop back to process next byte
L62A1:	CLR	R1
	BISB	(R3)+, R1		; get repeat count
L62A2:	MOVB	R0, (R2)+		; store repeated byte in buffer
	SOB	R1, L62A2		; repeat
	BR	L628F
; Buffer is ready, copy to screen
L62A9:	MOV	#SCRTOP, R3		; Screen start address
	MOV	#L6590, R2		; Tile screens address, used as a buffer
	MOV	#12., R4		; Number of columns = 12.
L62B1:	PUSH	R3			; save screen address
	MOV	#<24.*8.>, R1		; Number of lines = 24. * 8.
	MOV	R3, @#176640
L62B4:	MOVB	(R2)+, R0
	MOVB	REFBFH(R0), R0		; byte mirroring
	BIC	#177400, R0
	MOV	R0, @#176642		; put pixels on the screen
	ADD	#120, @#176640
	SOB	R1, L62B4		; continue loop for lines
	POP	R3			; restore screen address
	INC	R3			; next column
	SOB	R4, L62B1		; continue loop for columns
	RETURN

; Title picture (two ninjas), RLE encoded
.INCLUDE /S1PICT.MAC/
	.EVEN

;------------------------------------------------------------------------------

L7184:	.WORD	L791E	; Current Room address
L7186:	.WORD	LA0B5	; Ninja sprite address

L71C3:	.WORD	257.	; Current Guard position in tilemap
L71C5:	.BYTE	17.	; Current Guard X position
L71C6:	.BYTE	8.	; Current Guard Y position

L71CB:	.WORD	398.	; Dog position in tilemap
L71CD:	.BYTE	0	; Dog direction
L71CE:	.BYTE	8.	; Dog X position
L71CF:	.BYTE	0	; Dog state: 0 = run, 1 = changing direction, >= $42 is dead
L71D0:	.BYTE	7	; Dog's left limit
L71D1:	.BYTE	23.	; Dog's right limit
L71D2:	.BYTE	0	; Dog chaning direction: 0 = right to left, 1 = left to right
L71D3:	.BYTE	6	; Dog Y position
	.EVEN

L71D4:	.BYTE
L71D5:	.BYTE	1
L71D6:	.BYTE	172,000,000,002,000,001,026,000,375	; Room 79C6 dog data

L7232:	.BYTE	0	; Input bits: 000FUDLR
	.EVEN

L7239:	.BYTE	0	; Ninja direction: 0 = left, 1 = right
	.EVEN

; Mirror table
L723A:	.BYTE	001,201,101,301,041,241,141,341,021,221,121,321,061,261,161,361
	.BYTE	011,211,111,311,051,251,151,351,031,231,131,331,071,271,171,371
	.BYTE	005,205,105,305,045,245,145,345,025,225,125,325,065,265,165,365
	.BYTE	015,215,115,315,055,255,155,355,035,235,135,335,075,275,175,375
	.BYTE	003,203,103,303,043,243,143,343,023,223,123,323,063,263,163,363
	.BYTE	013,213,113,313,053,253,153,353,033,233,133,333,073,273,173,373
	.BYTE	007,207,107,307,047,247,147,347,027,227,127,327,067,267,167,367
	.BYTE	017,217,117,317,057,257,157,357,037,237,137,337,077,277,177,377
L72BA:	.BYTE	000,200,100,300,040,240,140,340,020,220,120,320,060,260,160,360
	.BYTE	010,210,110,310,050,250,150,350,030,230,130,330,070,270,170,370
	.BYTE	004,204,104,304,044,244,144,344,024,224,124,324,064,264,164,364
	.BYTE	014,214,114,314,054,254,154,354,034,234,134,334,074,274,174,374
	.BYTE	002,202,102,302,042,242,142,342,022,222,122,322,062,262,162,362
	.BYTE	012,212,112,312,052,252,152,352,032,232,132,332,072,272,172,372
	.BYTE	006,206,106,306,046,246,146,346,026,226,126,326,066,266,166,366
	.BYTE	016,216,116,316,056,256,156,356,036,236,136,336,076,276,176,376
REFBFH = L72BA

L733A:	.BYTE	0	; Ninja walking phase
	.EVEN
L733B:	; Table of four addresses of Ninja/Guard walking sprites
	.WORD	LD3DE			; Sprite Ninja/Guard walking 1
	.WORD	LD408			; Sprite Ninja/Guard walking 2
	.WORD	LD432			; Sprite Ninja/Guard walking 3
	.WORD	LD45C			; Sprite Ninja/Guard walking 4

L7343:	.BYTE	7	; Counter used in movement handlers
	.EVEN
L7344:	.BYTE	0	; Dog's flag: 1 = ignore left/right limit
	.EVEN
L7345:	.BYTE	20.	; Dog ??
	.EVEN
L7346:	.BYTE	10.	; Guard walking phase $00..$03 or other state: $09 = dead; $0A = standing; ...
L7347:	.BYTE	1	; Guard direction
	.EVEN

;
; Room token #0E: Put one tile at the given address; params: 3 bytes (tile, offset)
L734D:	POP	R3			; Restore token sequence address
	INC	R3			; Skip token byte
	MOVB	(R3)+, R0		; get tile byte
	CLR	R2
	BISB	(R3)+, R2		; get offset low byte
	SWAB	R2
	BISB	(R3), R2		; get offset high byte
	SWAB	R2
	ADD	#L6590, R2		; + Tile screen 0 address
	PUSH	R3
	MOVB	R0, (R2)		; put tile into tilemap
	BR	L734A			; => B702 Proceed to the next room token
; Room token #0D: Set border color; params: 1 byte
L7359:	HALT	; DO NOTHING, we're not processing this token
; Room token #01: Fill to down; params: 4 bytes (count, filler, offset)
L7381:	MOV	#30., R4		; shift = 30.
L7384:	POP	R3			; Restore token sequence address
	INC	R3			; Skip token byte
	CLR	R1
	BISB	(R3)+, R1		; get count byte
	MOVB	(R3)+, R0		; get tile byte
	CLR	R2
	BISB	(R3)+, R2		; get offset low byte
	SWAB	R2
	BISB	(R3), R2		; get offset high byte
	SWAB	R2
	ADD	#L6590, R2		; + Tile screen 0 address
	PUSH	R3
10$:	MOVB	R0, (R2)		; put tile into tilemap
	ADD	R4, R2			; apply the shift
	SOB	R1, 10$
	BR	L734A			; => Proceed to the next room token
; Room token #0A: Fill to down-right; params: 4 bytes (count, filler, offset)
L7395:	MOV	#31., R4		; shift = 30. + 1
	BR	L7384
; Room token #0B: Fill to down-left; params: 4 bytes (count, filler, offset)
L739A:	MOV	#29., R4		; shift = 30. - 1
	BR	L7384
; Room token #02: Fill to right; params: 4 bytes (count, filler, offset)
L739F:	MOV	#1, R4			; shift = 1
	BR	L7384
; Room token #06: Fill triangle from wide top; params: 4 bytes (filler, count, offset)
L73A4:	MOV	#1, R4			; shift = 1
L73A6:	POP	R3			; Restore token sequence address
	INC	R3			; Skip token byte
	MOVB	(R3)+, R0		; get tile byte
	CLR	R1
	BISB	(R3)+, R1		; get count byte
	CLR	R2
	BISB	(R3)+, R2		; get offset low byte
	SWAB	R2
	BISB	(R3), R2		; get offset high byte
	SWAB	R2
	ADD	#L6590, R2		; + Tile screen 0 address
	PUSH	R3
L73B8:	PUSH	R2
	MOV	R1, R3
L73BA:	MOVB	R0, (R2)		; put tile into tilemap
	ADD	R4, R2			; apply the shift
	SOB	R3, L73BA
	POP	R2
	ADD	#30., R2		; next row
	SOB	R1, L73B8		; continue loop by rows
L734A:	JMP	@#LB702			; => B702 Proceed to the next room token
; Room token #07: Fill triangle from wide bottom; params: 4 bytes (filler, count, offset)
L73C5:	MOV	#1, R4			; shift = 1
L73C7:	POP	R3			; Restore token sequence address
	INC	R3			; Skip token byte
	MOVB	(R3)+, R0		; get tile byte
	MOVB	(R3)+, R1		; get count byte
	CLR	R2
	BISB	(R3)+, R2		; get offset low byte
	SWAB	R2
	BISB	(R3), R2		; get offset high byte
	SWAB	R2
	ADD	#L6590, R2		; + Tile screen 0 address
	PUSH	R3
	MOV	#1, R3
L73DB:	PUSH	R3
	PUSH	R2
L73DD:	MOVB	R0, (R2)		; put tile into tilemap
	ADD	R4, R2			; apply the shift
	SOB	R3, L73DD
	POP	R2
	POP	R3
	INC	R3
	ADD	#30., R2		; next row
	SOB	R1, L73DB		; continue loop by rows
	BR	L734A			; => B702 Proceed to the next room token
; Room token #08: Fill triangle from wide bottom; params: 4 bytes (filler, count, offset)
L73EB:	MOV	#-1, R4			; shift = -1
	BR	L73C7
; Room token #09: Fill triangle from wide top
L73EF:	MOV	#-1, R4			; shift = -1
	BR	L73A6
; Room token #04: Fill whole Tile screen 0 with one tile; params: 1 byte (filler)
L73F3:	POP	R3			; Restore token sequence address
	INC	R3			; Skip token byte
	MOVB	(R3), R0		; get tile byte
	PUSH	R3
	MOV	#L6590, R2		; Tile screen 0 start address
	MOV	#510., R1		; count
10$:	MOVB	R0, (R2)+
	SOB	R1, 10$
	BR	L734A			; => B702 Proceed to the next room token
; Room token #05: Copy block of tiles; params: 5 bytes (width, height, source, offset)
L7406:	POP	R3			; Restore token sequence address
	INC	R3			; Skip token byte
	MOVB	(R3)+, R4		; get width
	MOVB	(R3)+, R1		; get count/height
	MOVB	(R3)+, R0		; get source index
	ASL	R0
	MOV	TBLOCK(R0), R0		; Convert source index to source address
	CLR	R2
	BISB	(R3)+, R2		; get offset low byte
	SWAB	R2
	BISB	(R3), R2		; get offset high byte
	SWAB	R2
	ADD	#L6590, R2		; + Tile screen 0 address
	PUSH	R3
L7415:	PUSH	R4
	PUSH	R2
L7416:	MOVB	(R0)+, (R2)+
	SOB	R4, L7416		; continue loop by columns
	POP	R2
	POP	R4
	ADD	#30., R2		; next row
	SOB	R1, L7415
	BR	L734A			; => B702 Proceed to the next room token
; Room token #0C: Copy block of tiles N times; params: 5 bytes (source, width, count, offset)
L742B:	POP	R3			; Restore token sequence address
	INC	R3			; Skip token byte
	MOVB	(R3)+, R0		; get source index
	ASL	R0
	MOV	TBLOCK(R0), R0		; Convert source index to source address
	MOVB	(R3)+, R4		; get width
	MOVB	(R3)+, R1		; get count/height
	CLR	R2
	BISB	(R3)+, R2		; get offset low byte
	SWAB	R2
	BISB	(R3), R2		; get offset high byte
	SWAB	R2
	ADD	#L6590, R2		; + Tile screen 0 address
	PUSH	R3
L743A:	PUSH	R0
	PUSH	R4
	PUSH	R2
L743D:	MOVB	(R0)+, (R2)+
	SOB	R4, L743D
	POP	R2
	ADD	#30., R2		; next row
	POP	R4
	POP	R0
	SOB	R1, L743A
	BR	L734A			; => B702 Proceed to the next room token
; Room token #03: Fill rectangle; params: 5 bytes (filler, width, height, offset)
L7452:	POP	R3			; Restore token sequence address
	INC	R3			; Skip token byte
	MOVB	(R3)+, R0		; get tile byte
	MOVB	(R3)+, R4		; get width
	MOVB	(R3)+, R1		; get count/height
	CLR	R2
	BISB	(R3)+, R2		; get offset low byte
	SWAB	R2
	BISB	(R3), R2		; get offset high byte
	SWAB	R2
	ADD	#L6590, R2		; + Tile screen 0 address
	PUSH	R3
L7463:	PUSH	R2
	PUSH	R4
L7465:	MOVB	R0, (R2)+
	SOB	R4, L7465
	POP	R4
	POP	R2
	ADD	#30., R2
	SOB	R1, L7463
	JMP	LB702			; => Proceed to the next room token

; Initial Energy fill
L7472:	MOV	#<SCRTOP+<1200*21.>+6>, R2	; screen address
	MOV	#15., R1
10$:	MOV	R2, @#176640
	MOV	#16., R4
20$:	MOV	#377, @#176642
	ADD	#120, @#176640		; next line
	SOB	R4, 20$
	INC	R2
	SOB	R1, 10$
	MOVB	#19., L749C		; set Energy = MAX
	CLRB	L749D
	RETURN

L749C:	.BYTE	19.			; Energy $04..$13
L749D:	.BYTE	1			; Energy lower, running bit

; Decreasing Energy
L749E:	TSTB	L749D
	BNE	10$
	DECB	L749C
	MOVB	#377, L749D
	BR	20$
10$:	CLC
	RORB	L749D
20$:	CALL	L74CC			; Draw Energy column
	RETURN

; Draw Energy column
L74CC:	MOVB	L749C, R2		; $04..$13
	ADD	#<SCRTOP+<1200*21.>+1>, R2	; screen address
	CLR	R1
	BISB	L749D, R1
	MOV	#16., R4
	MOV	R2, @#176640
10$:	MOV	R1, @#176642
	ADD	#120, @#176640		; next line
	SOB	R4, 10$
	RETURN

; Draw NEAR/HELD item
; R3 = address on the screen
L74CD:	MOV	#002, R0		; !!MUT-ARG!! item number 0..9
L74CE = L74CD + 2
	ASL	R0
L74D3:	MOV	#LB5B0, R2		; !!MUT-ARG!! address for Table of items
L74D4 = L74D3 + 2	; address for Table of items
	ADD	R0, R2
	MOV	(R2), R2		; get item address from the table
	MOV	#176640, R5
	MOV	R3, (R5)		; косвенный адрес УКНЦ
	MOV	#24., R1
L74E4:	CLR	R3			; <
	BISB	(R2)+, R3
	MOV	R3, @#176642		; | copy pixels
	INC	(R5)
	CLR	R3
	BISB	(R2)+, R3
	MOV	R3, @#176642		; | copy pixels
	INC	(R5)
	CLR	R3
	BISB	(R2)+, R3
	MOV	R3, @#176642		; | copy pixels
	INC	(R5)
	CLR	R3
	BISB	(R2)+, R3
	MOV	R3, @#176642		; | copy pixels
	ADD	#<120-3>, (R5)		; |  next line
	SOB	R1, L74E4		; repeat
	RETURN

L755B:	.BYTE	0			; Ninja falling count, to decrease Energy on hit
	.EVEN

L7918:	; Room procedure (for 19 rooms with a guard)
	JMP	LB44C
L791B:	; Rooms 7C9C/92EF initialization
	JMP	LB425

L9C40:	.BYTE	8.			; Ninja Y within the room, 0 at the top
	.EVEN
L9C41:	.BYTE	6			; Ninja X within the room
	.EVEN
L9C42:	.WORD	246.			; Ninja position in tilemap: Y * 30. + X

; Process a dog
L9C44:	MOV	#L71D3, R3		; Dog Y position address
	MOVB	L9C40, R0		; get Ninja Y
	MOVB	(R3), R1		; get Dog Y
	SUB	R1, R0			; R0 = Ninja Y - Dog Y
	CMPB	R0, #7
	BHIS	L9C80
	MOV	#L7345, R3
	TSTB	(R3)
	BNE	L9C5A
L9C56:	MOVB	#031, (R3)		; !!MUT-ARG!! ??
L9C57 = L9C56 + 2	; Dog counter value
	BR	L9C80
L9C5A:	DECB	(R3)
	BNE	L9C80
	TSTB	L71CD			; check Dog direction
	BNE	L9C71			; right =>
	MOVB	L9C41, R0		; get Ninja X
	INC	R0
	CMPB	R0, L71CE		; compare to Dog X position
	BLO	L9C80			; Ninja X + 1 < Dog X =>
	BR	L9C7B
L9C71:	MOVB	L9C41, R0		; get Ninja X
	INC	R0
	CMPB	R0, L71CE		; compare to Dog X position
	BHIS	L9C80			; Ninja X + 1 >= Dog X =>
L9C7B:	MOVB	#1, L7344		; set "Dog ignore left/right limit" flag
L9C80:	MOVB	@#L71CD, R0		; !!MUT-ARG!! get Dog direction
L9C81 = L9C80 + 2	; Dog direction address
	MOVB	R0, L71CD
	MOV	#L71CD, L9C81
	CALL	L9D5C			; Set update flags for Dog
	MOVB	L71CF, R0		; get Dog state
	CMPB	R0, #102		; $42, dead?
	BLO	L9CA8
	MOV	#L9C9C, R3		; Sprite Dog dead
	BR	L9D31			; => Set Dog sprite = HL, Draw Dog in tilemap

; Table for Dog sprites
L9CA4:	.WORD	L71F2	; Sprite Dog 1
	.WORD	L71FE	; Sprite Dog 2
	.WORD	L720A	; Sprite Dog 3

; Part of Dog processing, Dog is alive
; R0 = Dog state
L9CA8:	TSTB	R0			; = 0 ?
	BNE	L9D8B			; no => Dog changing direction
; Dog running
L9CAD:	MOV	L71CB, R3		; get Dog position in tilemap
	MOV	#<L698C+33.>, R2	; Tile screen 2 + 33.: for right direction
	TSTB	L71CD			; check Dog direction
	BNE	L9CBD			; right =>
	MOV	#<L698C+30.>, R2	; Tile screen 2 + 30.: for left direction
L9CBD:	ADD	R2, R3			; now R3 = Dog position in Ninja tile screen
	CMPB	#377, (R3)		; tile on Ninja screen = $FF ?
	BEQ	L9CC5			; $FF =>
	MOV	#5, R1
	CALL	L9DD9			; Dog bites, decrease Energy by 5
L9CC5:	TSTB	L71CD			; check Dog direction
	BEQ	L9CF1			; left =>
; Dog running right
L9CCC:	INC	L71CB			; increment Dog position in tilemap
	MOV	#L71CE, R3		; Dog X position address
	INCB	(R3)			; one tile right
	CMPB	#1, L7344
	BEQ	L9CE4
	CMPB	L71D1, (R3)		; compare to Dog's right limit
	BNE	L9D14
L9CE4:	CLRB	L7344
	CLRB	L71D2			; chaning direction right to left
	MOVB	#1, L71CF		; set state = change direction
	BR	L9D14
; Dog running left
L9CF1:	DEC	L71CB			; decrement Dog position in tilemap
	MOV	#L71CE, R3		; Dog X position address
	DECB	(R3)			; one tile left
	CMPB	#1, L7344
	BEQ	L9D09
	CMPB	L71D0, (R3)		; compare to Dog's left limit
	BNE	L9D14
L9D09:	CLRB	L7344
	MOVB	#1, L71D2		; chaning direction left to right
	MOVB	#1, L71CF		; set state = change direction
;
L9D14:	MOV	#L71D5, R3
	MOVB	(R3), R0
	INC	R0			; increase sprite counter
	CMPB	#3, R0
	BNE	L9D1F
	CLR	R0			; reset sprite counter
L9D1F:	MOVB	R0, (R3)		; save sprite counter
	ADD	R0, R0			; * 2
	MOV	L9CA4(R0), R3		; get sprite address from the table
;
; Set Dog sprite = HL, Draw Dog in tilemap
L9D31:	MOV	R3, L9D3C		; set Dog sprite = HL
;
; Draw Dog in tilemap
L9D34:	MOV	L71CB, R3		; get Dog position in tilemap
	ADD	#L6B8A, R3		; + Tile screen 3 start address
L9D3B:	MOV	#L71FE, R2		; !!MUT-ARG!! current Dog sprite address
L9D3C = L9D3B + 2	; current Dog sprite address
	MOV	#3, R1			; 3 rows
	TSTB	L71CD			; check Dog direction
	BEQ	L9D75			; left => draw Dog facing left

; Draw Dog facing right in tilemap
; R1 = 3 rows
L9D47:	MOVB	(R2)+, (R3)+
	MOVB	(R2)+, (R3)+
	MOVB	(R2)+, (R3)+
	MOVB	(R2)+, (R3)
	ADD	#27., R3		; next row
	SOB	R1, L9D47

L9D58:	;CALL	L9D5C			; Set update flags for Dog, 4x3 tiles
	;RETURN

; Set update flags for Dog, 4x3 tiles
L9D5C:	MOV	L71CB, R3		; get Dog position in tilemap
	ADD	#L678E, R3		; Tile screen 1 start address
	MOV	#3, R1			; 3 rows
	MOV	#001, R0		; "need to update" flag
10$:	MOVB	R0, (R3)+
	MOVB	R0, (R3)+
	MOVB	R0, (R3)+
	MOVB	R0, (R3)
	ADD	#<30.-3>, R3		; next row
	SOB	R1, 10$			; continue loop by rows
	RETURN

; Draw Dog facing left in tilemap
; R1 = 3 rows
L9D75:	ADD	#4, R3
L9D78:	MOVB	(R2)+, -(R3)
	MOVB	(R2)+, -(R3)
	MOVB	(R2)+, -(R3)
	MOVB	(R2)+, -(R3)
	ADD	#34., R3
	SOB	R1, L9D78
	BR	L9D58			; => Set update flags for Dog, and RET

; Part of Dog processing, Dog changing direction
L9D8B:	MOV	#L7216, L9D3C		; set Sprite Dog 4 - changing direction
	TSTB	L71D2			; check how we change direction
	BEQ	L9DB3
; Dog changing direction from left to right
	TSTB	L71CD			; check Dog direction
	BEQ	L9DA6			; left =>
	CLRB	L71CF			; set state = run
	BR	L9D34			; => Draw Dog in tilemap
L9DA6:	MOVB	#1, L71D4
	MOV	#L71D4, L9C81
	BR	L9D34			; => Draw Dog in tilemap
; Dog changing direction from right to left
L9DB3:	TSTB	L71CD			; check Dog direction
	BEQ	L9DC7			; left =>
	CLRB	L71D4
	MOV	#L71D4, L9C81
	BR	L9D34			; => Draw Dog in tilemap
L9DC7:	CLRB	L71CF			; set state = run
	BR	L9D34			; => Draw Dog in tilemap

; Initialize a Dog
; Input: R3 = Dog data address
L9DCD:	MOV	#L71CB, R2		; current dog data address
L9DD0:	MOV	R3, @#LB674		; save current Dog data address
	MOV	#9., R1			; 9 = size of Dog data
10$:	MOVB	(R3)+, (R2)+		; Copy Dog data
	SOB	R1, 10$
	RETURN

; Decrease Energy by R1
L9DD9:	RETURN				; !!MUT-CMD!! "PUSH R1" or "RETURN"
	CALL	L749E			; Decrease Energy
	POP	R1
	CMPB	#4, L749C		; Energy = MIN ?
	BNE	L9DF1
	CMPB	#1, L749D		; check Energy low
	BNE	L9DF1
	JMP	LBEAA			; Energy is out => Saboteur dead
L9DF1:	SOB	R1, L9DD9
	;DI
	RETURN

LA0DF:	; Room 94AB initialization
	MOV	#LA1E1, R3		; Guard data address
; Initialize a guard, then Standard room initialization
LA0E2:	CALL	LB40A			; Initialize a guard
LA0E5:	JMP	LB422			; Standard room initialization
LA0E8:	; Room 7DA9 initialization
	MOV	#LA1E7, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization
LA0ED:	; Room 7E8C initialization
	MOV	#LA1ED, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization
LA0F2:	; Room 920A initialization
	MOV	#LA1F3, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization
LA0F7:	; Room 8F84 initialization
	MOV	#LA1F9, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization
LA0FC:	; Room 8B71 initialization
	MOV	#LA1FF, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization
LA101:	; Room 8739 initialization
	MOV	#LA205, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization
LA106:	; Room 858F initialization
	MOV	#LA20B, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization
LA10B:	; Room 84EE initialization
	MOV	#LA211, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization
LA110:	; Room 99A6 initialization
	MOV	#LA21D, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization
LA115:	; Room 97F8 initialization
	MOV	#LA223, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization
LA11A:	; Room 94CF initialization
	MOV	#LA229, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization
LA11F:	; Room 9B51 initialization
	MOV	#LA22F, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization
LA124:	; Room 9F3A initialization
	MOV	#LA235, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization
LA129:	; Room 9F7E initialization
	MOV	#LA23B, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization
LA12E:	; Room 9EB8 initialization
	MOV	#LA241, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization
LA133:	; Room 9B19 initialization
	MOV	#LA247, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization
LA138:	; Room 9DF5 initialization
	MOV	#LA24D, R3		; Guard data address
	BR	LA0E2			; Initialize a guard, then Standard room initialization

LA142:	; Room 7A17 initialization
	MOV	#LA33E, R3		; Turret data address
; Initialize a turret, then Standard room initialization
LA145:	CALL	LB461			; Initialize a turret
	BR	LA0E5			; Standard room initialization
LA14A:	; Room 7D5A initialization
	MOV	#LA32F, R3		; Turret data address
	BR	LA145			; Initialize a turret, then Standard room initialization
LA14F:	; Room 7F48 initialization
	MOV	#LA332, R3		; Turret data address
	BR	LA145			; Initialize a turret, then Standard room initialization
LA154:	; Room 7EF2 initialization
	MOV	#LA299, R3		; Dog data address
	CALL	L9DCD			; Initialize a dog
	MOV	#LA338, R3		; Turret data address
	BR	LA145			; Initialize a turret, then Standard room initialization
LA15F:	; Room 909F initialization
	MOV	#LA2E9, R3		; Dog data address
	CALL	L9DCD			; Initialize a dog
	MOV	#LA338, R3		; Turret data address
	BR	LA145			; Initialize a turret, then Standard room initialization
LA16A:	; Room 8FBD initialization
	MOV	#LA335, R3		; Turret data address
	BR	LA145			; Initialize a turret, then Standard room initialization
LA16F:	; Room 92A7 initialization
	MOV	#LA338, R3		; Turret data address
	BR	LA145			; Initialize a turret, then Standard room initialization
LA174:	; Room 8B25 initialization
	MOV	#LA33B, R3		; Turret data address
	BR	LA145			; Initialize a turret, then Standard room initialization
LA179:	; Room 8526 initialization
	MOV	#LA33E, R3		; Turret data address
	BR	LA145			; Initialize a turret, then Standard room initialization

LA183:	; Room 95D6 initialization
	MOV	#LA344, R3		; Turret data address
	BR	LA145			; Initialize a turret, then Standard room initialization
LA188:	; Room 968A initialization
	MOV	#LA347, R3		; Turret data address
	BR	LA145			; Initialize a turret, then Standard room initialization
LA18D:	; Finish Room 97A6 initialization
	MOV	#LA34A, R3		; Turret data address
	BR	LA145			; Initialize a turret, then Standard room initialization
LA192:	; Room 9A9A initialization
	MOV	#LA332, R3		; Turret data address
	BR	LA145			; Initialize a turret, then Standard room initialization
LA197:	; Room 9552 initialization
	MOV	#LA34D, R3		; Turret data address
	BR	LA145			; Initialize a turret, then Standard room initialization
LA19C:	; Room 9BE7 initialization
	MOV	#LA350, R3		; Turret data address
	BR	LA145			; Initialize a turret, then Standard room initialization
LA1A1:	; Room 8D5C initialization
	MOV	#LA33B, R3		; Turret data address
	BR	LA145			; Initialize a turret, then Standard room initialization
LA1A6:	; Room 7C2E initialization
	MOV	#LA271, R3		; Dog data address
	CALL	L9DCD			; Initialize a dog
	MOV	#LA253, R3		; Guard data address
LA1AF:	; Finish room initialization
	CALL	LB40A			; Initialize a guard
	JMP	LB422			; Standard room initialization
LA1B5:	; Room 7F9C initialization
	MOV	#LA27B, R3		; Dog data address
	CALL	L9DCD			; Initialize a dog
	MOV	#LA259, R3		; Guard data address
	BR	LA1AF			; Initialize a guard, then Standard room initialization
LA1C0:	; Room 8162 initialization
	MOV	#LA28F, R3		; Dog data address
	CALL	L9DCD			; Initialize a dog
	MOV	#LA265, R3		; Guard data address
	BR	LA1AF			; Initialize a guard, then Standard room initialization
LA1CB:	; Room 80A7 initialization
	MOV	#LA2AD, R3		; Dog data address
	CALL	L9DCD			; Initialize a dog
	MOV	#LA265, R3		; Guard data address
	BR	LA1AF			; Initialize a guard, then Standard room initialization
LA1D6:	; Room 9B9D initialization
	MOV	#LA325, R3		; Dog data address
	CALL	L9DCD			; Initialize a dog
	MOV	#LA26B, R3		; Guard data address
	BR	LA1AF			; Initialize a guard, then Standard room initialization

; Guards data, 23 records, 6 bytes each
; +$04: Guard state, initially $0A
; +$05: Guard direction
LA1E1:	.BYTE	235,000,007,005,012,001	; Room 94AB guard
LA1E7:	.BYTE	030,001,012,011,012,000	; Room 7DA9 guard
LA1ED:	.BYTE	024,001,006,011,012,000	; Room 7E8C guard
LA1F3:	.BYTE	023,001,005,011,012,000	; Room 920A guard
LA1F9:	.BYTE	310,000,024,006,012,000	; Room 8F84 guard
LA1FF:	.BYTE	040,001,022,011,012,001	; Room 8B71 guard
LA205:	.BYTE	120,000,024,002,012,001	; Room 8739 guard
LA20B:	.BYTE	036,001,020,011,012,000	; Room 858F guard
LA211:	.BYTE	001,001,021,010,012,001	; Room 84EE guard
;LA217:	.BYTE	030,001,012,011,012,000	; UNUSED, see A13D
LA21D:	.BYTE	042,001,024,011,012,001	; Room 99A6 guard
LA223:	.BYTE	371,000,011,010,012,000	; Room 97F8 guard
LA229:	.BYTE	002,001,022,010,012,001	; Room 94CF guard
LA22F:	.BYTE	337,000,015,007,012,001	; Room 9B51 guard
LA235:	.BYTE	367,000,007,010,012,001	; Room 9F3A guard
LA23B:	.BYTE	370,000,010,010,012,000	; Room 9F7E guard
LA241:	.BYTE	206,000,016,004,012,001	; Room 9EB8 guard
LA247:	.BYTE	242,000,014,005,012,000	; Room 9B19 guard
LA24D:	.BYTE	273,000,007,006,012,000	; Room 9DF5 guard
LA253:	.BYTE	302,000,016,006,012,000	; Room 7C2E guard
LA259:	.BYTE	324,000,002,007,012,000	; Room 7F9C guard
LA25F:	.BYTE	013,000,013,000,012,001	; Room 8162 guard
LA265:	.BYTE	040,001,022,011,012,001	; Room 80A7 guard
LA26B:	.BYTE	060,000,022,001,012,001	; Room 9B9D guard

; Dogs data, 19 records, 10 bytes each
; +$00/$01: Dog position in tilemap
; +$02: Dog direction
; +$03: Dog X position
; +$04: ??
; +$05: Dog left limit
; +$06: Dog right limit
; +$07: ??
; +$08: Dog Y position
LA271:	.BYTE	074,001,000,020,000,003,026,000,003,001	; Room 7C2E dog
LA27B:	.BYTE	136,001,001,024,000,003,026,001,004,001	; Room 7F9C dog
LA285:	.BYTE	245,000,000,017,000,005,017,000,376,001	; Room 81E5 dog
LA28F:	.BYTE	172,000,001,002,000,000,030,001,375,001	; Room 8162 dog
LA299:	.BYTE	217,001,001,011,000,003,030,001,006,001	; Room 7EF2 dog
LA2A3:	.BYTE	212,001,001,004,000,002,032,001,006,001	; Room 7E05 dog
LA2AD:	.BYTE	232,001,000,024,001,003,025,001,006,001	; Room 80A7 dog
LA2B7:	.BYTE	222,001,000,014,000,005,031,000,006,001	; Room 83ED dog
LA2C1:	.BYTE	214,001,001,006,001,001,027,000,006,001	; Room 80F6 dog
LA2CB:	.BYTE	220,001,000,012,000,004,027,000,006,001	; Room 924E dog
LA2D5:	.BYTE	033,001,001,015,000,006,030,001,002,001	; Room 91BA dog
LA2DF:	.BYTE	166,001,001,016,000,000,017,001,005,001	; Room 90DB dog
LA2E9:	.BYTE	227,001,001,021,000,015,032,001,006,001	; Room 909F dog
LA2F3:	.BYTE	274,000,000,010,000,001,016,000,377,001	; Room 8802 dog
LA2FD:	.BYTE	244,000,000,016,000,002,016,000,376,001	; Room 8608 dog
LA307:	.BYTE	216,001,000,010,000,007,027,000,006,001	; Room 844E dog
LA311:	.BYTE	215,001,001,007,000,003,025,001,006,001	; Room 9739 dog
LA31B:	.BYTE	366,000,000,006,000,002,017,000,001,001	; Room 9A5A dog
LA325:	.BYTE	214,001,001,006,000,004,030,001,006,001	; Room 9B9D dog

; Turrets data, 11 records, 3 bytes each
LA32F:	.BYTE	304,000,016	; Room 7A17 turret
LA332:	.BYTE	047,000,007	; Room 7F48/9A9A turret
LA335:	.BYTE	021,000,017	; Room 8FBD turret
LA338:	.BYTE	053,000,012	; Room 7EF2/909F/92A7 turret
LA33B:	.BYTE	113,000,015	; Room 8B25/8D5C turret
LA33E:	.BYTE	057,000,017	; Room 7A17/8526 turret
;LA341:	.BYTE	062,000,022	; UNUSED, see A17E
LA344:	.BYTE	235,000,005	; Room 95D6 turret
LA347:	.BYTE	246,000,016	; Room 968A turret
LA34A:	.BYTE	012,001,030	; Room 968A turret
LA34D:	.BYTE	077,000,001	; Room 9552 turret
LA350:	.BYTE	243,000,013	; Room 9BE7 turret
	.EVEN

LA353:	; Room 81E5 initialization
	MOV	#LA285, R3		; Dog data address
; Initialize a dog, then Standard room initialization
LA356:	CALL	L9DCD			; Initialize a dog
	JMP	LB422			; Standard room initialization
LA35C:	; Room 7E05 initialization
	MOV	#LA2A3, R3		; Dog data address
	BR	LA356			; Initialize a dog, then Standard room initialization
LA361:	; Room 83ED initialization
	MOV	#LA2B7, R3		; Dog data address
	BR	LA356			; Initialize a dog, then Standard room initialization
LA366:	; Room 924E initialization
	MOV	#LA2CB, R3		; Dog data address
	BR	LA356			; Initialize a dog, then Standard room initialization
LA36B:	; Room 91BA initialization
	MOV	#LA2D5, R3		; Dog data address
	BR	LA356			; Initialize a dog, then Standard room initialization
LA370:	; Room 90DB initialization
	MOV	#LA2DF, R3		; Dog data address
	BR	LA356			; Initialize a dog, then Standard room initialization
LA375:	; Room 8802 initialization
	MOV	#LA2F3, R3		; Dog data address
	BR	LA356			; Initialize a dog, then Standard room initialization
LA37A:	; Room 8608 initialization
	MOV	#LA2FD, R3		; Dog data address
	BR	LA356			; Initialize a dog, then Standard room initialization
LA37F:	; Room 844E initialization
	MOV	#LA307, R3		; Dog data address
	BR	LA356			; Initialize a dog, then Standard room initialization
LA384:	; Room 9739 initialization
	MOV	#LA311, R3		; Dog data address
	BR	LA356			; Initialize a dog, then Standard room initialization
LA389:	; Room 9A5A initialization
	MOV	#LA31B, R3		; Dog data address
	BR	LA356			; Initialize a dog, then Standard room initialization
LA38E:	; Room 80F6 initialization
	MOV	#LA2C1, R3		; Dog data address
	BR	LA356			; Initialize a dog, then Standard room initialization

LA39E:	.BYTE	0
	.EVEN

; Three objects, 8. bytes each
; 1st object - object thrown by Ninja
LA39F:	.BYTE	0			; Thrown object tile
	.EVEN
LA3A0:	.WORD	304			; Thrown object position
LA3A2:	.BYTE	0
LA3A3:	.BYTE	3
LA3A4:	.BYTE	6			; Thrown object Y
LA3A5:	.BYTE	4			; Thrown object X
; 2nd object
LA3A6:	.BYTE	0
	.BLKB	7
; 3rd object - Turett
LA3AD:	.BYTE	0
	.EVEN
LA3AE:	.WORD	105.			; Turret offset in tilemap
LA3B0:	.BYTE	6
LA3B1:	.BYTE	6
LA3B2:	.BYTE	3			; Turret Y
LA3B3:	.BYTE	15.			; Turret X

LA3B4:	.BYTE	1			; ?? Guard counter
	.EVEN

; Ninja and Guard in 12. tiles by X
LA3B5:	CMPB	L9C40, L71C6		; compare Ninja Y to Guard Y
	BEQ	10$			; same Y =>
	RETURN
10$:	POP	R3
LA3BE:	MOV	#20., R0
LA3BF = LA3BE + 2
	MOVB	R0, LA3B4
	MOVB	#11., L7346		; set Guard state = $0B
	MOV	#LD504, LA70F		; set Sprite Ninja/Guard punching
	JMP	LA6FF			; => Draw Guard on tilemap

; Ninja and Guard in 9. tiles by X
LA3D1:	CMPB	L9C40, L71C6		; compare Ninja Y to Guard Y
	BEQ	10$			; same Y =>
99$:	RETURN
10$:	TSTB	LA3A6
	BNE	99$
	POP	R3
	MOVB	20., L7346		; set Guard state = $14
	MOV	#LD504, LA70F		; set Sprite Ninja/Guard punching
	JMP	LA6FF			; => Draw Guard on tilemap

; Ninja and Guard in 3 tiles by X
LA3EE:	CMPB	L9C40, L71C6		; compare Ninja Y to Guard Y
	BEQ	10$			; same Y =>
99$:	RETURN
10$:	MOV	L71C3, R3		; get Guard position in tilemap
	ADD	#<L6590+2>, R3		; + Tile screen 0 + 2
	MOV	#144, R0		; $64
	CMPB	R0, (R3)
	BLO	99$
	INC	R3
	CMPB	R0, (R3)
	BLO	99$
	POP	R3
	MOVB	#5, L7346		; set Guard state = $05
	MOVB	#2, LA3B4
	MOV	#LD4B0, LA70F		; set Sprite Ninja/Guard jumping
	JMP	LA6FF			; => Draw Guard on tilemap

; Ninja and Guard are very close by X
LA418:	CMPB	L9C40, L71C6		; compare Ninja Y to Guard Y
	BEQ	10$			; same Y =>
	RETURN
10$:	POP	R3
	MOVB	#8., L7346		; set Guard state = $08
	MOVB	#3, LA3B4		; set Guard counter = 3
	MOV	#LD504, LA70F		; set Sprite Ninja/Guard punching
	JMP	LA6FF			; => Draw Guard on tilemap

; Process a Guard
LA434:	CALL	LA75B			; Set update flags for Guard, 6x7 tiles
	MOV	#L7346, R3		; Guard state address
	MOVB	(R3), R0		; get Guard state
; Guard state = $0B ?
	CMPB	R0, #11.
	BNE	LA4E7
	MOV	#LA3B4, R3		; Guard counter address
	DECB	(R3)			; decrease Guard counter
	CMPB	(R3), #6
	BLO	LA44A
	JMP	LA6FF			; => Draw Guard on tilemap
LA44A:
	;TODO
	MOVB	L71C6, R0		; get Guard Y
	ADD	R0, R0			; Guard Y * 2

	;TODO
	;HALT

	;XOR A
	;OUT ($FE),A
	TSTB	LA3B4			; check Guard counter
	BNE	90$			; => Draw Guard on tilemap
	MOVB	#4., L7346		; set Guard state = $04
90$:	JMP	LA6FF			; => Draw Guard on tilemap
; Guard state = $14 ?
LA4E7:	CMPB	R0, #20.
	BNE	LA52F

	;TODO
	HALT

	JMP	LA6FF			; => Draw Guard on tilemap
; Guard state = $0A ? - Standing
LA52F:	CMPB	R0, #10.
	BNE	LA56D
	MOV	#LD486, LA70F		; set Sprite Ninja/Guard standing
	MOV	#L9C40, R3		; Ninja Y address
	MOVB	L71C6, R0		; get Guard Y
	ADD	#3, R0			; Guard Y + 3
	CMPB	R0, (R3)		; compare with Ninja Y
	BHIS	LA545
	JMP	LA6FF			; Guard above Ninja => Draw Guard on tilemap
LA545:	MOVB	LA39E, R0
	DEC	R0
	BEQ	LA565
	MOVB	L71C5, R0		; get Guard X
	TSTB	L7347			; check Guard direction
	BEQ	LA55F			; right =>
	ADD	#2, R0			; for left, Guard X + 2
	CMPB	R0, (R3)		; compare with Ninja X
	BLO	LA55D
	JMP	LA6FF			; Guard still behind Ninja => Draw Guard on tilemap
LA55D:	BR	LA565
LA55F:	SUB	#3, R0			; for right, Guard X - 3
	CMPB	R0, (R3)		; compare with Ninja X
	BHIS	LA565
	JMP	LA6FF			; Guard not reached Ninja => Draw Guard on tilemap
LA565:	MOVB	#4, L7346		; set Guard state = $04
	JMP	LA6FF			; => Draw Guard on tilemap
; Guard state = $09 ? - Guard is dead
LA56D:	CMPB	#9., R0
	BNE	LA57A
	MOV	#LA0B5, LA70F		; set Sprite Ninja/Guard dead
	JMP	LA6FF			; => Draw Guard on tilemap
; Guard state = $08 ? - Punching ?
LA57A:	CMPB	#8., R0
	BNE	LA5AA
	DECB	LA3B4			; decrease Guard counter
	BEQ	LA587
	JMP	LA6FF			; => Draw Guard on tilemap
LA587:	MOVB	#3, (R3)		; set Guard state = walking state 3
	MOV	L71C3, R3		; get Guard position in tilemap
	MOV	#<L698C+64.>, R2	; Tile screen 2 + 2 rows + 4
	TSTB	L7347			; check Guard direction
	BNE	LA599
	MOV	#<L698C+61.>, R2	; Tile screen 2 + 2 rows + 1
LA599:	ADD	R2, R3
	CMPB	#377, (R3)
	BEQ	LA5A1
	MOV	#6, R1
	CALL	LFA31			; => Decrease Energy by B + Sound
LA5A1:	MOV	#LD486, LA70F		; set Sprite Ninja/Guard standing
	JMP	LA6FF			; => Draw Guard on tilemap
; Guard state = $05 ? - Jump
LA5AA:	CMPB	#5., R0
	BNE	LA5C7
	DECB	LA3B4			; decrement Guard counter
	BNE	90$
	MOVB	#3, LA3B4		; set Guard counter = 3
	MOVB	#6, (R3)		; set Guard state = $06: jump-kick
	MOV	#LD4DA, LA70F		; set Sprite Ninja/Guard jump-kick
90$:	JMP	LA6FF			; => Draw Guard on tilemap
; Guard state = $06 ? Jump-kick
LA5C7:	CMPB	#6., R0
	BNE	LA614
	DECB	LA3B4			; decrement Guard counter
	BNE	90$
	MOVB	#1, LA3B4		; set Guard counter = 1
	MOVB	#7, (R3)		; set Guard state = $07: back to standing
	MOV	#LD4B0, LA70F		; set Sprite Ninja/Guard jumping
	MOV	L71C3, R3		; get Guard position in tilemap
	MOV	#<L698C+65.>, R2	; Tile screen 2 + 65.
	TSTB	L7347			; check Guard direction
	BNE	10$			; right =>
	MOV	#<L698C+60.>, R2	; Tile screen 2 + 60.
10$:	ADD	R2, R3
	CMPB	#377, (R3)
	BEQ	90$
	MOV	#10., R1		; 10. damage
	CALL	LFA31			; Decrease Energy + Sound
90$:	JMP	LA6FF			; => Draw Guard on tilemap
; Guard state is none of the above
LA614:	MOVB	L9C41, R1		; get Ninja X
	MOVB	L71C5, R0		; get Guard X
	SUB	R1, R0			; now R0 = Guard X - Ninja X
	BNE	LA635
	CALL	LA418
	MOV	#L7346, R3		; Guard state address
	CMPB	#10., (R3)		; Guard state = $0A ?
	BNE	LA629
	JMP	LA6FF			; yes => Draw Guard on tilemap
LA629:	MOVB	#4, (R3)		; set Guard state = $04
	MOV	#LD486, LA70F		; set Sprite Ninja/Guard standing
	BR	LA6FF			; => Draw Guard on tilemap
; Guard X != Ninja X
LA635:	BLO	LA68C			; Guard X < Ninja X =>
; Ninja X < Guard X
	MOV	R0, R1			; save value "Guard X - Ninja X"
	TSTB	L7347			; check Guard direction
	BEQ	LA65B			; left =>
	CMPB	#4, L7346		; Guard state = $04 ?
	BEQ	LA654			; yes =>
	MOVB	#4, L7346		; set Guard state = $04
	MOV	#LD486, LA70F		; set Sprite Ninja/Guard standing
	BR	LA6FF			; => Draw Guard on tilemap
LA654:	CLRB	L7347			; set Guard direction = left
	BR	LA6FF			; => Draw Guard on tilemap
LA65B:	MOV	R1, R0			; restore value "Guard X - Ninja X"
	CMPB	#3, R0
	BNE	LA661
	CALL	LA3EE
LA661:	CMPB	#1, R0
	BNE	LA666
	CALL	LA418
LA666:	CMPB	#9., R0
	BNE	LA66B
	CALL	LA3D1
LA66B:	CMPB	#12., R0
	BNE	LA670
	CALL	LA3B5
LA670:	CMPB	#4, L7346		; Guard state = $04 ?
	BNE	LA67F			; no =>
	MOVB	#3, L7346		; set Guard state = walking phase 3
	BR	LA6FF			; => Draw Guard on tilemap
LA67F:	DEC	L71C5			; decrement Guard X - move one tile left
	CLRB	L7347			; set Guard direction = left
	MOV	#-1, R2
	BR	LA6DE
;
; Guard X < Ninja X
LA68C:	MOV	R0, R1			; save value "Guard X - Ninja X"
	TSTB	L7347			; check Guard direction
	BNE	LA6AF			; right =>
	CMPB	#4, L7346		; Guard state = $04 ?
	BEQ	LA6A8			; yes =>
	MOVB	#4, L7346		; set Guard state = $04
	MOV	#LD486, LA70F		; set Sprite Ninja/Guard standing
	BR	LA6FF			; => Draw Guard on tilemap
LA6A8:	MOVB	#1, L7347		; set Guard direction = right
	BR	LA6FF			; => Draw Guard on tilemap
LA6AF:	MOV	R1, R0			; restore value "Guard X - Ninja X"
	CMPB	#-3, R0
	BNE	LA6B5
	CALL	LA3EE
LA6B5:	CMPB	#-1, R0
	BNE	LA6BA
	CALL	LA418
LA6BA:	CMPB	#-9., R0
	BNE	LA6BF
	CALL	LA3D1
LA6BF:	CMPB	#-12., R0
	BNE	LA6C4
	CALL	LA3B5
LA6C4:	CMPB	#4, L7346		; Guard state = $04 ?
	BNE	LA6D2
	MOVB	#3, L7346		; set Guard state = walking phase 3
	BR	LA6FF			; => Draw Guard on tilemap
LA6D2:	INC	L71C5			; increment Guard X - move one tile right
	MOVB	#1, L7347		; set Guard direction = right
	MOV	#1, R2
;
LA6DE:	ADD	R2, L71C3		; Guard position in tilemap +1 / -1
	MOVB	L7346, R0		; get Guard state
	INC	R0
	BIC	#177774, R0			; 0..3
	MOVB	R0, L7346		; set Guard state
	ADD	R0, R0			; * 2
	MOV	L733B(R0), LA70F	; sprite from table -> set Guard sprite
;
; Draw Guard on tilemap
LA6FF:	MOV	L71C3, R3		; get Current Guard position in tilemap
	TSTB	L7347			; check Guard direction
	BNE	LA728			; right =>
	ADD	#<L6D88+6>, R3		; Tile screen 4 start address + 6
LA70E:	MOV	#LD432, R2		; !!MUT-ARG!! current Ninja/Guard sprite address
LA70F = LA70E + 2
	MOV	#7, R1			; 7 rows
LA713:	MOVB	(R2)+, R0		; get tile
	CALL	LA775			; Translate Ninja tile A into Guard tile
	MOVB	R0, -(R3)
	MOVB	(R2)+, R0
	CALL	LA775
	MOVB	R0, -(R3)
	MOVB	(R2)+, R0
	CALL	LA775
	MOVB	R0, -(R3)
	MOVB	(R2)+, R0
	CALL	LA775
	MOVB	R0, -(R3)
	MOVB	(R2)+, R0
	CALL	LA775
	MOVB	R0, -(R3)
	MOVB	(R2)+, R0
	CALL	LA775
	MOVB	R0, -(R3)
	ADD	#36., R3		; next row
	SOB	R1, LA713
	RETURN
LA728:	ADD	#L6D88, R3		; Tile screen 4 start address
	MOV	LA70F, R2		; get Guard sprite address
	MOV	#7, R1			; 7 rows
LA732:	MOVB	(R2)+, R0		; get tile
	CALL	LA775			; Translate Ninja tile A into Guard tile
	MOVB	R0, (R3)+
	MOVB	(R2)+, R0
	CALL	LA775
	MOVB	R0, (R3)+
	MOVB	(R2)+, R0
	CALL	LA775
	MOVB	R0, (R3)+
	MOVB	(R2)+, R0
	CALL	LA775
	MOVB	R0, (R3)+
	MOVB	(R2)+, R0
	CALL	LA775
	MOVB	R0, (R3)+
	MOVB	(R2)+, R0
	CALL	LA775
	MOVB	R0, (R3)
	ADD	#25., R3		; next row
	SOB	R1, LA732
	RETURN

; Set update flags for Guard, 6x7 tiles
LA75B:	MOV	L71C3, R3		; get Current Guard position in tilemap
	ADD	#L678E, R3		; Tile screen 1 start address
	MOV	#7, R1			; 7 rows
	MOV	#001, R0		; "need to update" flag
10$:	MOVB	R0, (R3)+		; 6 columns
	MOVB	R0, (R3)+
	MOVB	R0, (R3)+
	MOVB	R0, (R3)+
	MOVB	R0, (R3)+
	MOVB	R0, (R3)
	ADD	#<30.-5>, R3		; next row
	SOB	R1, 10$			; continue loop by rows
	RETURN

; Translate Ninja tile R0 into Guard tile, using LA787 table
LA775:	CMPB	#377, R0
	BEQ	99$
	MOV	#LA787, R4		; Translate table address
10$:	CMPB	(R4)+, R0
	BEQ	20$
	CMPB	#377, (R4)
	BNE	10$
	RETURN
20$:	MOVB	(R4), R0
99$:	RETURN

; Table used to translate Ninja tiles to Guard tiles, 19 records
LA787:	.BYTE	120,307,121,334,124,335,352,336,023,337,025,340,026,341,000,342
	.BYTE	001,343,003,344,004,345,115,346,042,347,057,350,060,351,364,342
	.BYTE	365,343,344,344,366,345
	.BYTE	377,377

; Reset Guard data and Dog data
LAC44:	MOV	#LAC72, R3		; address for Table of Guard data addresses
	MOV	#23., R1		; 23. Guard records
LAC49:	MOV	(R3)+, R2		; now R2 = Guard data address
	MOVB	#10., 4(R2)		; set initial Guard state = $0A
	SOB	R1, LAC49
; Now prepare Dogs
	MOV	#LACA2, R3
	MOV	#20., R1		; 23. Dog records
LAC5C:	MOV	(R3)+, R2		; now R2 = Dog data address
	ADD	#4, R2
	CMPB	#101, (R2)		; $41 ?
	BHIS	LAC6E
	MOVB	(R2), R0
	SUB	#102, R0		; $42
	MOVB	R0, (R2)
LAC6E:	SOB	R1, LAC5C
	RETURN

; Table of Guard data addresses, 23. records
LAC72:	.WORD	LA26B,LA265,LA25F,LA259
	.WORD	LA253
	;.WORD	LA217	;UNUSED
	.WORD	LA24D,LA247
	.WORD	LA241,LA23B,LA235,LA22F
	.WORD	LA229,LA223,LA21D,LA211
	.WORD	LA20B,LA205,LA1FF,LA1F9
	.WORD	LA1F3,LA1ED,LA1E7,LA1E1

; Table of Dog data addresses, 20. records
LACA2:	.WORD	LA31B,LA311,LA307,LA2FD
	.WORD	LA2F3,LA2DF,LA2D5,LA2CB
	.WORD	LA2C1,LA2B7,LA2A3,LA285
	.WORD	LA325,LA2AD,LA28F,LA27B
	.WORD	LA271,LA2E9,LA299,L71D6

; LA7AD:
.INCLUDE /S1ITEM.MAC/
	.EVEN

; Draw game screen frames and indicator text
LACCA:
	MOV	#SCRTOP, @#176640	; Screen start address
	MOV	#LAD65, R2		; Game screen frames/indicators RLE encoded sequence
	CLR	R5			; counter up to 32.
10$:	CLR	R0
	BISB	(R2)+, R0
	CMPB	#377, R0
	BEQ	LAD1D
	PUSH	R2
	MOV	#1, R1
	CMPB	R0, #23.		; $17 ?
	BLO	20$
	SUB	#20., R0
	MOV	R0, R1
	POP	R2
	CLR	R0
	BISB	(R2)+, R0
	PUSH	R2
20$:	MOV	R0, R2
	ASL	R0
	ASL	R0
	ASL	R0			; * 8.
	ADD	R0, R2			; * 9.
	ADD	#LAE02, R2		; Indicator tiles address
27$:	MOV	#8., R4
30$:	CLR	R0
	BISB	(R2)+, R0
	MOV	R0, @#176642		; Пишем данные в ВОЗУ УКНЦ
	ADD	#120, @#176640		; next line
	SOB	R4, 30$
	SUB	#<1200-1>, @#176640	; next column
	INC	R5
	BIC	#177740, R5		; keep 5 lower bits = 0..31.
	BNE	40$
	ADD	#<1200-40>, @#176640	; next row
40$:	SUB	#8., R2
	SOB	R1, 27$
	POP	R2
	BR	10$
LAD1D:
	MOV	#<SCRIND+7.>, R2
	MOV	#13., R1
	MOV	#LAD4A, R3		; Indicator messages start address
	CALL	LAED1			; Print string "PAY : $ 00000"
	MOV	#<SCRIND+1200+23.>, R2	; screen address for timer value
	MOV	#2, R1
	CALL	LAED1			; Print string "99"
	MOV	#<SCRIND+3600+1.>, R2
	MOV	#4, R1
	CALL	LAED1			; Print string "HELD"
	MOV	#<SCRIND+3600+22.>, R2
	MOV	#4, R1
	CALL	LAED1			; Print string "TIME"
	MOV	#<SCRIND+3600+27.>, R2
	MOV	#4, R1
	CALL	LAED1			; Print string "NEAR"
	RETURN

; Indicator messages
LAD4A:	.ASCII	/PAY : $ /
LAD52:	.ASCII	/00000/			; Pay value text
LAD57:	.ASCII	/99/			; Indicator time value
LAD59:	.ASCII	/HELDTIMENEAR/

.INCLUDE /S1INDS.MAC/
	.EVEN

; Print string on the screen
; Input: R1 = length, R2 = screen address, R3 = string address
LAED1:
1$:	CLR	R0
	BISB	(R3)+, R0		; get symbol byte
	ASL	R0
	ASL	R0
	ASL	R0			; * 8
	ADD	#<LC721-400>, R0	; + font base address
	MOV	#8., R4
10$:	CLR	R5
	BISB	(R0), R5
	SWAB	R5
	BISB	(R0)+, R5
	MOV	R2, @#176640		; Пишем адрес в ВОЗУ УКНЦ
	MOV	R5, @#176642		; Пишем данные в ВОЗУ УКНЦ
	ADD	#120, R2		; к следующей строке экрана
	SOB	R4, 10$
	SUB	#<1200-1>, R2		; на 8. строк выше, плюс колонка вправо
	SOB	R1, 1$
	RETURN

LAEF0:
	;TODO
LAF7E:
	;TODO
LAF84:
	;TODO

LAF9C:
	;TODO
LAFAA:
	;TODO
LAFBE:
	;TODO

; Print table of records
LB005:
	;TODO
	RETURN

LB040:
	;TODO
	BR	LAFBE

LB061:	.ASCII	/00  $/

; Table of records
LB066:	.ASCII	/020 THE CAT  /
	.ASCII	/018JOOLZ     /
	.ASCII	/016MICKY     /
	.ASCII	/014DAVE      /
	.ASCII	/012GEOFF P   /
	.ASCII	/010SHARFACE  /
	.ASCII	/008HOLLY     /
	.ASCII	/006BRAD      /
	.ASCII	/004TOZZY     /
	.ASCII	/002MAT LE FAT/

LB0E8:	.ASCII	/          /		; String 10 spaces

LB0F2:	.ASCII	/EXCELLENT WORK./
	.ASCII	/OU ARE ONE OF/
	.ASCII	/ OUR TEN BEST/
	.ASCII	/NINJA SABOTEURS./
	.ASCII	/ENTER YOUR NAME.../
	.EVEN

;------------------------------------------------------------------------------

L722F:	.WORD	0			; address in Tile screen 0
L7231:	.WORD	0			; address in Tile screen 2
L7233:	.WORD	0			; address in Tile screen 3
L7235:	.WORD	0			; address in Tile screen 4
L7237:	.WORD	0			; address in Tile screen 5

; Tile buffer
LB13E:	.BLKB	8.			; Pixel bytes
	.BYTE	0			; Attribute byte
	.BYTE	0			; Background attribute byte

; Draw tile map on the screen
LB148:	MOV	#17., R1		; 17. rows
	MOV	#<SCRTOP+1200+1>, @#176640	; screen address
	MOV	#L678E, R3		; start address in Tile screen 1
	MOV	#L6590, L722F		; start address in Tile screen 0
	MOV	#L698C, L7231		; start address in Tile screen 2
	MOV	#L6B8A, L7233		; start address in Tile screen 3
	MOV	#L6D88, L7235		; start address in Tile screen 4
	MOV	#L6F86, L7237		; start address in Tile screen 5
; Loop start
LB16D:	PUSH	R1			; save rows counter
	MOV	#30., R4		; 30. columns
LB16F:	PUSH	R4			; save columns counter
	PUSH	R3			; save address in Tile screen 1
	MOVB	(R3), R0		; check "need update" flag in Tile screen 1
	BNE	LB177			; not zero => do the tile rendering
; Next column
	ADD	#1, @#176640		; screen address +1
LB2A9:	MOV	#L722F, R3
	INC	(R3)+			; next address in Tile screen 0
	INC	(R3)+			; next address in Tile screen 2
	INC	(R3)+			; next address in Tile screen 3
	INC	(R3)+			; next address in Tile screen 4
	INC	(R3)			; next address in Tile screen 5
	POP	R3			; restore address in Tile screen 1
	INC	R3			; next address in Tile screen 1
	POP	R4			; restore columns counter
	SOB	R4, LB16F		; continue loop by columns
; Next tile row
	ADD	#<1200-30.>, @#176640	; screen address to next row
	POP	R1			; restore rows counter
	SOB	R1, LB16D		; continue loop by rows
	RETURN

; Do the tile rendering
LB177:	CLRB	(R3)			; clear "need to update" flag
; Process Tile screen 0 - background tile
	MOVB	@L722F, R0		; get tile from Tile screen 0
	CMPB	#377, R0		; $FF - "earth" background?
	;TODO
	BIC	#17400, R0
	ASL	R0
	ASL	R0
	ASL	R0			; * 8.
	ADD	#LF700, R0		; + Background tiles base address
	;TODO
	MOV	R0, R3
	MOV	#LB13E, R2		; buffer address
	MOV	(R3)+, (R2)+		; copy two bytes
	MOV	(R3)+, (R2)+
	MOV	(R3)+, (R2)+
	MOV	(R3)+, (R2)+		; copied 8. bytes
; Process Tile screen 2 tile - Ninja
LB1A3:	MOV	L7231, R3		; get address in Tile scrren 2
	MOVB	(R3), R0		; get tile from Tile screen 2
	CMPB	#377, R0		; $FF ?
	BEQ	LB1FC			; $FF => skip Ninja tile drawing
	BIC	#17400, R0
	ASL	R0
	ASL	R0
	ASL	R0
	ASL	R0			; * 16.
	ADD	#LE700, R0		; + Ninja tiles base address
	MOV	R0, R3			; now HL = tile data address
	MOV	#8., R1			; 8 bytes
	MOV	#LB13E, R2		; tile buffer address
LB1E4:	MOVB	(R2), R0		; get byte from the buffer
	MOVB	(R3)+, R5		; get mask byte
	;CALL	LB2E8			; Mirror byte if needed
	TSTB	L7239			; check direction
	BNE	10$			; right =>
	MOVB	L72BA(R5), R5		; byte mirroring
10$:	BICB	R5, R0			; apply the mask
	MOVB	(R3)+, R5		; get pixels byte
	;CALL	LB2E8			; Mirror byte if needed
	TSTB	L7239			; check direction
	BNE	20$			; right =>
	MOVB	L72BA(R5), R5		; byte mirroring
20$:	BISB	R5, R0			; apply the pixels
	MOVB	R0, (R2)+		; store byte back to the buffer
	SOB	R1, LB1E4
; Process Tile screen 3 tile - Dog
LB1FC:	MOV	L7233, R3		; get address in Tile scrren 3
	MOVB	(R3), R0		; get tile from Tile screen 3
	CMPB	#377, R0		; $FF ?
	BEQ	LB230			; $FF => skip Dog tile drawing
	BIC	#17400, R0
	ASL	R0
	ASL	R0
	ASL	R0
	ASL	R0			; * 16.
	ADD	#LF0F0, R0		; + Dog tiles base address
	MOV	R0, R3			; now HL = tile data address
	MOV	#8., R1
	MOV	#LB13E, R2		; tile buffer address
LB218:	MOVB	(R2), R0		; get byte from the buffer
	MOVB	(R3)+, R5		; get mask byte
	TSTB	L71CD			; check Dog direction
	BNE	10$			; right =>
	MOVB	L72BA(R5), R5		; byte mirroring
10$:	BICB	R5, R0			; apply the mask
	MOVB	(R3)+, R5		; get pixels byte
	TSTB	L71CD			; check Dog direction
	BNE	20$			; right =>
	MOVB	L72BA(R5), R5		; byte mirroring
20$:	BISB	R5, R0			; apply the pixels
	MOVB	R0, (R2)+		; store byte back to the buffer
	SOB	R1, LB218
; Process Tile screen 4 tile - Guard
LB230:	MOV	L7235, R3		; get address in Tile scrren 4
	MOVB	(R3), R0		; get tile from Tile screen 4
	CMPB	#377, R0		; $FF ?
	BEQ	LB263			; $FF => skip Guard tile drawing
	BIC	#17400, R0
	ASL	R0
	ASL	R0
	ASL	R0
	ASL	R0			; * 16.
	ADD	#LE700, R0		; + Guard tiles base address
	MOV	R0, R3			; now HL = tile data address
	MOV	#8., R1
	MOV	#LB13E, R2		; tile buffer address
LB24B:	MOVB	(R2), R0		; get byte from the buffer
	MOVB	(R3)+, R5		; get mask byte
	TSTB	L7347			; check direction
	BNE	10$			; right =>
	MOVB	L72BA(R5), R5		; byte mirroring
10$:	BICB	R5, R0			; apply the mask
	MOVB	(R3)+, R5		; get pixels byte
	TSTB	L7347			; check direction
	BNE	20$			; right =>
	MOVB	L72BA(R5), R5		; byte mirroring
20$:	BISB	R5, R0			; apply the pixels
	MOVB	R0, (R2)+		; store byte back to the buffer
	SOB	R1, LB24B
; Process Tile screen 5 tile - front
LB263:	MOV	L7237, R3		; get address in Tile scrren 5
	MOVB	(R3), R0		; get tile from Tile screen 5
	CMPB	#377, R0		; $FF - transparent?
	BEQ	LB293			; $FF => skip front tile drawing
	BIC	#17400, R0
	ASL	R0
	ASL	R0
	ASL	R0
	ASL	R0			; * 16.
	ADD	#LD600, R0		; + front tiles base address
	MOV	R0, R3
	MOV	#LB13E, R2		; buffer address
	MOV	#8., R1
10$:	MOVB	(R2), R0		; get byte from the buffer
	BICB	(R3)+, R0		; apply the mask
	BISB	(R3)+, R0		; apply the pixels
	MOVB	R0, (R2)+		; store byte back to the buffer
	SOB	R1, 10$
; Draw prepared tile on the screen
LB293:	MOV	#LB13E, R2
	MOV	#8., R1
LB29B:	CLR	R0
	BISB	(R2)+, R0		; get byte from the buffer
	MOV	R0, @#176642		; put byte on the screen
	ADD	#120, @#176640		; screen address next line
	SOB	R1, LB29B
;
	ADD	#<1-1200>, @#176640	; screen address +1
	JMP	LB2A9			; continue the loop

; Mirror byte if needed
;LB2E8:	TSTB	L7239			; check direction
;	BNE	LB2FC			; right => return
;	MOVB	L72BA(R5), R5		; byte mirroring
;LB2FC:	RETURN

LB2FD:	.BYTE	195.			; Counter for Ninja/Guard head tile change
	.EVEN

;------------------------------------------------------------------------------

; Object procedure: flip trigger "D": set/remove wall in room 9739
LB320:	MOV	#6, R0
	;TODO	XOR	R0, L9756
	BR	LB350			; => Change Console color in NEAR
; Object procedure: flip trigger "E": set/remove wall in room 97A6
LB32A:	MOV	#377, R0
	;TODO
	BR	LB350			; => Change Console color in NEAR
; Object procedure: flip trigger "C": set/remove wall in room 8D5C
LB334:	MOV	#6, R0
	;TODO
	BR	LB350			; => Change Console color in NEAR
; Object procedure: flip trigger "B": set/remove wall in room 8F20
LB33E:	MOV	#8., R0
	;TODO
	BR	LB350			; => Change Console color in NEAR
; Object procedure: flip trigger "A": set/remove wall in room 7F48
LB348:	MOV	#9., R0
	;TODO
LB350:
	;TODO
LB365:	JMP	@#LB8D0			; => Update Ninja on tilemap

; Room 97A6 initialization
LB368:
	;TODO
	JMP	LA18D			; => Finish Room 97A6 initialization

; Play melody ??; HL = melody address
LB371:
	RETURN	;STUB

; Room token #00: Barrel, 3x3 tiles 7C21; params: 2 bytes (offset)
LB38F:	POP	R3			; Restore token sequence address
	INC	R3			; Skip token byte
	CLR	R2
	BISB	(R3)+, R2		; get offset low byte
	SWAB	R2
	BISB	(R3), R2		; get offset high byte
	SWAB	R2
	ADD	#L6590, R2		; + Tile screen 0 address
	PUSH	R3
	MOV	#L7C21, R3		; Tile block address
	MOV	#3, R1			; 3 rows
LB39B:	MOVB	(R3)+, (R2)+
	MOVB	(R3)+, (R2)+
	MOVB	(R3)+, (R2)
	ADD	#28., R2
	SOB	R1, LB39B
	JMP	LB702			; => Proceed to the next room token

LB3B0:	MOV	#LC681, <L982B+2>
	MOV	#LB674, <L9DD0+2>	; current dog data address
	MOV	#LC6A5, L7C9C
	MOV	#LC671, R3
	MOV	R3, <L947C+2>
	MOV	R3, <L93DF+2>
	MOV	#LB422, <L7BD2+2>
	MOV	#LC64C, <L791E+2>
	MOV	#LB702, <L734A+2>
	;TODO
	;NOTE: Mirror table preparation was here
	JMP	LB5C7

; Initialize a Guard
; Input: R3 = Guard data address, see A1E1
LB40A:	MOV	#L71C3, R2		; address to store guard data
	MOV	R3, LB696		; Save Guard data address
	MOV	(R3)+, (R2)+		; copy Guard data - position in tilemap
	MOV	(R3)+, (R2)		; copy Guard data - X/Y position
	MOVB	(R3)+, L7346		; set Guard state
	MOVB	(R3)+, L7347		; set Guard direction
	RETURN

; Standard room procedure (for 63 rooms)
LB41F:	JMP	LB937
; Standard room initialization (for 60 rooms)
;NOTE: LB422 now just alias for LB724	; => Finish room initialization
; Rooms 7C9C/92EF initialization (redirect from 791B)
LB425:	MOV	#LC66B, R3		; Guard data address
	CALL	LB40A			; Initialize a guard
	JMP	LB724			; => Finish room initialization
; Room 79C6 initialization
LB42E:	MOV	#L71D6, R3		; Dog data address
	CALL	L9DCD			; Initialize a dog
	JMP	LB724			; => Finish room initialization
; Room B513 procedure (initial Room)
LB446:	CALL	LB4FA			; Processing in the initial room
	JMP	LB937			; Standard room procedure
; Room procedure (for 19 rooms with a guard) (redirect from 7918)
LB44C:	CALL	LA434			; Process a guard
	JMP	LB937			; Standard room procedure
; Room procedure (for 18 rooms with a dog)
LB452:	CALL	L9C44			; Process a dog
	JMP	LB937			; Standard room procedure
; Room procedure (for 5 rooms with a guard and a dog)
LB458:	CALL	L9C44			; Process a dog
	CALL	LA434			; Process a guard
	JMP	LB937			; Standard room procedure

; Turret initialization
; R3 = Turret data address
LB461:	CLR	R2
	BISB	(R3)+, R2
	SWAB	R2
	BISB	(R3)+, R2
	SWAB	R2			; now R2 = Turret offset
	ADD	#L678E, R2		; + Tile screen 1 start address
	MOV	R2, LB4CC		; set Turret address on Tile Screen 1
	ADD	#2040., R2
	MOV	R2, LB48E		; set Turret address on Tile Screen 5
	MOVB	(R3), LB4D4
	RETURN

; Room procedure (for 2 rooms with a turret and a dog)
LB47A:	CALL	L9C44			; Process a dog
	CALL	LB489			; Process turret
	JMP	LB937			; Standard room procedure

; Room procedure (for 14 rooms with a turret)
LB483:	CALL	LB489			; Process turret
	JMP	LB937			; Standard room procedure

; Process turret
LB489:	MOVB	LB4DD, R0		; get Turret counter
LB48D:	MOV	#<L6F86+47.>, R3	; !!MUT-ARG!! Turret address on Tile Screen 5
LB48E = LB48D + 2	; Turret address on Tile Screen 5
	DEC	R0
	BNE	LB4C6
	MOVB	(R3), R0
	PUSH	R3
	SUB	#L6F86, R3		; now R3 = Turret offset in tilemap
	SUB	#046, R0
	MOVB	R0, LA3B0
	MOVB	R0, <LA3B0+1>
	MOV	R3, LA3AE
	MOVB	#332, LA3AD		; $DA
	MOV	#30., R2
	CLR	R1
LB4B4:	SUB	R2, R3			; -30.
	INC	R1
	CMPB	R3, R2			; >= 30. ?
	BHIS	LB4B4			; yes =>
	MOVB	R3, LA3B3		; Turret X
	MOVB	R1, LA3B2		; Turret Y
LB4C3:	MOV	#50., R0		; !!MUT-ARG!! ??
	POP	R3
LB4C6:	MOVB	R0, LB4DD		; update Turret counter
LB4CB:	MOVB	#1, @#<L678E+47.>	; !!MUT-ARG!! set "need update" mark for Turret on Tile Screen 1
LB4CC = LB4CB + 4	; Turret address on Tile Screen 1
	MOVB	#055, (R3)		; $2D = Turret looking down
	MOVB	L9C41, R0		; get Ninja X
LB4D3:	MOV	#15., R1		; !!MUT-ARG!! Turret X value
LB4D4 = LB4D3 + 2	; Turret X value
	CMPB	R0, R1
	BEQ	99$
	DECB	(R3)
	CMPB	R0, R1
	BMI	99$
	INCB	(R3)
	INCB	(R3)
99$:	RETURN

LB4DD:	.BYTE	50.	; Turret counter 50..0
	.EVEN

; Increase PAY value by B * 100.
LB4DE:	MOV	#<LAD52+2>, R3		; PAY value 3rd digit address
LB4E3:	INCB	(R3)
	CMPB	#072, (R3)		; ':' = '9' + 1
	BNE	LB4ED
	MOVB	#060, (R3)		; '0'
	DEC	R3			; previous digit
	BR	LB4E3
LB4ED:	SOB	R1, LB4DE
	MOV	#LAD52, R3		; Pay value text address
	MOV	#5, R1			; five digits
	MOV	#<SCRTOP+<1200*19.>+15.>, R2	; Screen address
	JMP	LAED1			; => Print string, and RET

; Processing in initial room - the boat moving
LB4FA:
	;TODO: Update front tile
	MOV	#<L678E+<30.*9.>>, R3
	MOV	#30., R1
10$:	MOVB	#1, (R3)+		; put "need update" mark
	SOB	R1, 10$
	RETURN

; Movement handler for initial room (B8CE handler)
LB532:	INC	L9C42			; increase Ninja position in tilemap
	INCB	L9C41			; increase Ninja X
LB53D:	MOV	#<L6F86+349.>, R2	; !!MUT-ARG!! address in Tile screen 5 (front)
LB53E = LB53D + 2	; Boat position
	MOV	#LB5A7, R3		; Boat sprite address
	MOV	#9., R1
10$:	MOVB	(R3)+, (R2)+
	SOB	R1, 10$
	ADD	#-2041., R2
	MOVB	#1, (R2)		; put "need update" flag
	ADD	#-8., R2
	MOVB	#1, (R2)		; put "need update" flag
	INC	@#LB53E			; increase boat position
	;TODO
	DECB	L7343			; decrease counter
	BEQ	LB577
	JMP	LB8D0			; => Update Ninja on tilemap
LB577:	INCB	L9C41			; increrase Ninja X
	INC	L9C42			; increase Ninja position in tilemap
	MOVB	#377, <L6F86+349.>
	MOV	#LD5AC, R2		; Sprite Ninja jumping 3
	MOV	#LC4F6, R3		; Movement handler address
	MOVB	#4, L7343		; set counter = 4
	JMP	LBFB0			; Set movement handler = R3, Ninja sprite = R2

LB595:	.BYTE	0			; action cooldown counter
	.EVEN

LB596:	MOV	20., R1
LB598:	JMP	LF9A1

; Sound ??
LB59E:
	;TODO
	RETURN

; Table of items: addresses for NEAR/HELD items
LB5B0:	.WORD	LA7AD	; #0 Nothing
	.WORD	LA819	; #1 Shuriken
	.WORD	LA885	; #2 Knife
	.WORD	LA8F1	; #3 ??
	.WORD	LA95D	; #4 Brick
	.WORD	LA9C9	; #5 Pipe
	.WORD	LAA35	; #6 Granade
	.WORD	LAAA1	; #7 Disk
	.WORD	LAB0D	; #8 Bomb
	.WORD	LAB79	; #9 Console

LB5C4:	.BYTE	25	; Time fast counter 50..0
LB5C5:	.BYTE	1	; Ninja standing counter
LB5C6:	.BYTE	0	; Time mode: 0 = time ticking; 1 = Time stopped; 2 = BOMB ticking mode
	.EVEN

LB5C7:	CALL	LAC44			; Reset Guard data and Dog data
	;TODO
	MOV	#010146, L9DD9		; set command = PUSH R1 = enable Energy decrease
	;TODO
	MOV	#LB8D0, R3		; Object procedure address for "Update Ninja on tilemap"
	MOV	R3, <LD280+6>		; set Object procedure for object #6 in Table of objects D256
	MOV	R3, <LB365+2>
	MOVB	#060, R0		; "0"
	MOV	#LAD52, R3		; Pay value text address
	MOVB	R0, (R3)+
	MOVB	R0, (R3)+
	MOVB	R0, (R3)
	CALL	LACCA			; Draw game screen frames and indicator text
	;NOP				; set BORDCR = 0
	CLRB	LB5C6			; set Time mode = time ticking
	CLR	LB850			; clear HELD tile
	CLRB	<LD486+8.>		; set head tile in Ninja/Guard standing sprite
	;TODO: Sound off
	MOVB	#1, <LD486+9.>		; set head tile for Ninja/Guard standing sprite
	MOVB	#1, L7239		; set Ninja direction = 1 = right
	MOVB	#1, LB84F		; set NEAR item = 1
	MOV	#<L6F86+330.>, @#LB53E	; set initial position for boat
	MOV	#LB5B0, L74D4
	CALL	LB851			; Set initial data in Table of Objects
	CLR	LB674			; set current Dog data address = no dog
	CLR	LB696			; set current Guard data address = no guard
	MOVB	#4, <LC66B+4>		; set status for Guard in rooms 7C9C/92EF
	MOVB	#4, <LD486+15.>		; set tile in Sprite Ninja/Guard standing sprite
	MOVB	#250., LB2FD		; $FA set counter for head animation
	MOVB	#310, LBD7A		; $C8 Shuriken - set HELD tile
	CALL	L7472
	;DI
	MOV	#LB513, L7184		; set Current Room = Initial room
	MOV	#LB532, LB8CE		; set movement handler = movement handler for initial room
	MOV	#LD558, L7186		; set Ninja sprite = Ninja sitting
	MOVB	#1, L9C41		; set Ninja X = 1
	MOVB	#5, L9C40		; set Ninja Y = 5
	MOV	#151., L9C42		; set Ninja position in tilemap: Y * 30. + X
	MOVB	#19., L7343		; set counter = 19.

; Current Room changed, entering the new Room
LB66A:	MOVB	L71D4, R0
;LB66D:	MOVB	R0, @#000000
;LB66E = LB66D + 2
	;TODO

; If we have a Dog, copy it's data
	TST	LB674			; have a dog in the room?
	BEQ	LB67B			; no => skip copying
	MOV	#L71CB, R3
LB673:	MOV	#000000, R2		; !!MUT-ARG!! current Dog data address
LB674 = LB673 + 2	; current Dog data address
	MOV	#9., R1
LB679:	MOVB	(R3)+, (R2)+
	SOB	R1, LB679
LB67B:
	;TODO

; If we have a Guard, copy his data
	TST	LB696
	BEQ	LB6A6
	MOV	#L71C3, R3
LB695:	MOV	#000000, R2		; !!MUT-ARG!! current Guard data address
LB696 = LB695 + 2
	MOVB	(R3)+, (R2)+
	MOVB	(R3)+, (R2)+
	MOVB	(R3)+, (R2)+
	MOVB	(R3)+, (R2)+
	MOVB	L7346, (R2)+		; copy Guard state
	MOVB	L7347, (R2)+		; copy Guard direction
;
LB6A6:	CLR	LB674			; set current Dog data address = no dog
	CLR	LB696			; set current Guard data address = no guard
	CLRB	LBAB2
; Clear 3 objects at LA39F
	MOV	#LA39F, R3		; Three objects start address
	MOV	#3, R1
LB6BB:	CLRB	(R3)
	ADD	#8., R3
	SOB	R1, LB6BB
;
	MOV	#L6590, R3		; Tile screen 0 start address
	MOV	#<510./2>, R1
LB6CD:	CLR	(R3)+			; clear two bytes
	SOB	R1, LB6CD
	;TODO
	MOV	#L6D88, R3		; Tile screen 4 start address
	MOV	#510., R1		; to fill Tile Tile screen 4 and Tile screen 5
LB6DA:	MOV	#177777, (R3)+		; put two bytes $FF = transparent tile
	SOB	R1, LB6DA
	MOV	L7184, R3		; get Current Room address
	MOV	2(R3), LB6F2		; set Room init address
	ADD	#12., R3		; now R3 = room sequence start address
LB6EE:	CLR	R0
	BISB	(R3), R0		; get next token
	CMPB	#377, R0		; End of sequence?
	BNE	LB6F4			; no =>
LB6F1:	JMP	@#LB724			; !!MUT-ARG!! => run Room initialization code
LB6F2 = LB6F1 + 2	; Room initialization address
LB6F4:	PUSH	R3			; Save address in the room sequence
	ASL	R0			; * 2
	ADD	#<LB706>, R0		; Table of Room tokens
	MOV	(R0), R0		; get token procedure address
	JMP	@R0			; => run token procedure
;
; Proceed to the next room token
LB702:
	POP	R3			; Restore address in the room sequence
	INC	R3			; to next token
	BR	LB6EE			; => continue room sequence processing

; Table of Room tokens
LB706:	.WORD	LB38F	; #00: Put 3x3 tiles $7C21; params: 2 bytes (address)
LB708:	.WORD	L7381	; #01: Fill to down; params: 4 bytes (count, filler, address)
LB70A:	.WORD	L739F	; #02: Fill to right; params: 4 bytes (count, filler, address)
LB70C:	.WORD	L7452	; #03: Fill rectangle; params: 5 bytes (filler, width, height, address)
LB70E:	.WORD	L73F3	; #04: Fill whole Tile screen 0 with one tile; params: 1 byte (filler)
LB710:	.WORD	L7406	; #05: Copy block of tiles; params: 5 bytes (width, height, source, address)
LB712:	.WORD	L73A4	; #06: Fill triangle from wide top; params: 4 bytes (filler, count, address)
LB714:	.WORD	L73C5	; #07: Fill triangle from wide bottom; params: 4 bytes (filler, count, address)
LB716:	.WORD	L73EB	; #08: Fill triangle from wide bottom; params: 4 bytes (filler, count, address)
LB718:	.WORD	L73EF	; #09: Fill triangle from wide top; params: 4 bytes (filler, count, address)
LB71A:	.WORD	L7395	; #0A: Fill to down-right; params: 4 bytes (count, filler, address)
LB71C:	.WORD	L739A	; #0B: Fill to down-left; params: 4 bytes (count, filler, address)
LB71E:	.WORD	L742B	; #0C: Copy block of tiles N times; params: 5 bytes (source, width, count, address)
LB720:	.WORD	L7359	; #0D: Set border color; params: 1 byte
LB722:	.WORD	L734D	; #0E: Put one tile at the given address; params: 3 bytes (tile, address)

; Finish room initialization
; Called to finish room initialization from room initialization procedure
LB724:	MOV	#L678E, R3		; Tile screen 1 start address
LB422 = LB724
	MOV	#<510./2>, R1
10$:	MOV	#401, (R3)+		; put two bytes $01
	SOB	R1, 10$
; R3 = L698C (Tile screen 2 start address)
	MOV	#510., R1		; to fill Tile screen 2 and Tile screen 3
20$:	MOV	#177777, (R3)+		; put two bytes $FF = transparent tile
	SOB	R1, 20$
	CALL	LB148			; Draw tile map on the screen
;
	MOV	#LD34D, R3		; Table of objects address
	MOV	#35., R1		; 35 objects
LB753:	PUSH	R3			; save address in Table of objects
	CMP	(R3)+, L7184		; is it current room?
	BNE	LB768			; no =>
	MOV	(R3)+, R2		; get offset
	ADD	#L6590, R2		; now R2 = address in Tile screen 0
	MOVB	(R3), R0		; get tile byte
	MOVB	R0, (R2)		; set tile byte in Tile screen
LB768:	POP	R3			; restore address in Table of objects
	ADD	#6, R3			; next object
	SOB	R1, LB753
;
	CMPB	#9., L7346 		; Guard state = 9. ?
	BEQ	LB77B			; no => skip
	MOVB	#10., L7346		; set Guard state = $0A
;
; Game loop start
LB77B:
	;TODO
	CMPB	#1, LB5C6		; Time mode = stopped ?
	BEQ	LB7AF			; yes =>
; Decrease Time, check if Time is out
	MOV	#LB5C4, R3		; address for Time fast counter
	DECB	(R3)			; decrease the counter
	BNE	LB7AF			; not zero => skip Time decrease
	MOVB	#TIMERI, (R3)		; reset fast counter
	MOV	#<LAD57+1>, R3		; address for Time lower digit
	DECB	(R3)			; Decrease Time lower digit
	CMPB	#057, (R3)		; $2F = '0' - 1
	BNE	LB7A4
	MOVB	#071, (R3)		; '9'
	DEC	R3			; go to higher digit
	DECB	(R3)			; decrease Time higher digit
	CMPB	#057, (R3)		; $2F = '0' - 1
	BNE	LB7A4
	JMP	LBE71
LB7A4:	MOV	#<SCRIND+1200+23.>, R2	; screen address for timer value
	MOV	#LAD57, R3		; Indicator Time value address
	MOV	#2, R1			; Two digits
	CALL	LAED1			; Print string
;
; Check for BOMB
LB7AF:	CMPB	#326, @#<LD256+<8.*7>+4>	; check Object #7 in Table of objects D256
	BNE	LB7ED			; BOMB tile in the place of Diskette? no =>
; BOMB ticking mode
LB7B6:	MOV	#LB5C6, R3		; Time mode address
	CMPB	#2, (R3)		; already in BOMB ticking mode?
	BEQ	LB7ED			; yes =>
; Set up BOMB ticking mode
	MOVB	#2, (R3)		; set Time mode = BOMB ticking mode
	MOV	#LBD2F, R3		; "BOMB"
	MOV	#<SCRIND+3600+22.>, R2	; screen address under timer value
	MOV	#4, R1
	CALL	LAED1			; Print string "BOMB"
LB7CA:	MOV	#34471, R3		; !!MUT-ARG!! "99" bomb timer initial value
	MOV	R3, LAD57		; set Indicator Time value
	MOVB	#1, LB5C4
	;TODO: Как-то подсветить индикатор времени
	MOV	#50., R1
	CALL	LB4DE			; Increase PAY value by 5000
LB7ED:	MOV	#L678E, R3		; Tile screen 1 start address
	MOV	#<510./2>, R1
10$:	CLR	(R3)+			; put two bytes $00 = "no need to update" value
	SOB	R1, 10$
	CALL	LBBBB			; Set update flags for Ninja, 6x7 tiles
	MOV	#L698C, R3		; Tile screen 2 start address
	MOV	#<510./2>, R1
20$:	MOV	#177777, (R3)+		; put two bytes $FF
	SOB	R1, 20$
	CLRB	LB84C			; clear Object tile
	MOV	#35., R1		; 35. = number of records in LD256
	MOV	#LD256, R2		; Table address
; Loop through the table
LB814:	MOV	(R2)+, R3		; get offset
	ADD	#L6590, R3
	ADD	L9C42, R3		; add Ninja position in tilemap
	CMPB	(R2)+, (R3)		; compare to byte +$02
	BNE	LB889
	CLR	R1
	BISB	(R2)+, R1		; get byte +$03
	MOV	R2, LB84A		; store Object address + 4
	MOVB	(R2)+, LB84C		; copy byte +$04 - object tile
	INC	R2			; skip even-filler
	MOV	(R2), LB84D		; copy object procedure address
	BR	LB891
LB889:	ADD	#5, R2
	SOB	R1, LB814		; continue the loop through the table
; R1 = tile found, or 0 = not found
LB891:	MOV	#LB84F, R3		; NEAR item address
	CMPB	R1, (R3)		; same item?
	BEQ	LB8B0			; yes => skip
	MOVB	R1, (R3)		; set NEAR item
	MOVB	R1, L74CE		; set item to draw
	MOV	#<SCRIND+27.>, R3	; screen address for NEAR item
	CALL	L74CD			; Draw NEAR/HELD item
LB8B0:	MOV	#LB850, R3		; HELD tile address
	CLR	R0
	BISB	LBD7A, R0		; get HELD tile
	CMPB	R0, (R3)		; HELD changing?
	BEQ	LB8C9			; no => skip
	MOVB	R0, (R3)		; set HELD tile
	BEQ	LB8C2
	SUB	#306, R0		; $C6
	ASR	R0
LB8C2:	MOVB	R0, L74CE		; set item to draw
	MOV	#<SCRIND+1>, R3		; screen address for HELD item
	CALL	L74CD			; Draw NEAR/HELD item
	;DI
LB8C9:	CLRB	LA39E
LB8CD:	JMP	@#LBEB3			; !!MUT-ARG!! => run handler
LB8CE = LB8CD + 2	; Movement handler address

; Increase Energy a bit
LB83C:	CMPB	#377, L749D
	BNE	10$
	CMPB	#19., L749C		; Energy at MAX?
	BEQ	99$			; yes => return
	CLRB	L749D
	INCB	L749C
	BR	20$
10$:	SEC
	ROLB	L749D
20$:	CALL	L74CC			; Draw Energy column
99$:	RETURN

LB84A:	.WORD	0			; Object address + 4, in table LD256
LB84C:	.BYTE	0			; Object tile
	.EVEN
LB84D:	.WORD	0			; Object procedure address
LB84F:	.BYTE	0			; NEAR item
	.EVEN
LB850:	.BYTE	0			; HELD tile
	.EVEN

; Set initial data in Table of Objects LD256
LB851:	MOV	#35., R1		; 35 objects
	MOV	#<LD256+3>, R4		; address for Table of Objects + 3
	MOV	#LD210, R3		; address for table with initial data
10$:	MOVB	(R3)+, (R4)+		; set byte +$03 in the record
	MOVB	(R3), (R4)		; set byte +$04 in the record
	ADD	#<8.-1>, R4		; next record
	SOB	R1, 10$			; continue the loop
	RETURN

;NOTE: Procedure B86C removed, not used

; Update Ninja on tilemap
LB8D0:	CALL	LBBBB			; Set update flags for Ninja, 6x7 tiles
	MOV	#L6D88, R3		; Tile screen 4 start address
	MOV	#<510./2>, R1
10$:	MOV	#177777, (R3)+
	SOB	R1, 10$
; Draw Ninja on tilemap
LB8E0:	MOV	L9C42, R3		; get Ninja position in tilemap
	MOV	L7186, R2		; get Ninja sprite address
	MOV	#7, R1			; 7 rows
	TSTB	L7239			; get Ninja direction
	BNE	LB907			; right =>
	ADD	#<L698C+6>, R3		; Tile screen 2 start address + 6
10$:	MOVB	(R2)+, -(R3)
	MOVB	(R2)+, -(R3)
	MOVB	(R2)+, -(R3)
	MOVB	(R2)+, -(R3)
	MOVB	(R2)+, -(R3)
	MOVB	(R2)+, -(R3)
	ADD	#<30.+6>, R3
	SOB	R1, 10$
	BR	LB922
LB907:	ADD	#L698C, R3		; Tile screen 2 start address
20$:	MOVB	(R2)+, (R3)+
	MOVB	(R2)+, (R3)+
	MOVB	(R2)+, (R3)+
	MOVB	(R2)+, (R3)+
	MOVB	(R2)+, (R3)+
	MOVB	(R2)+, (R3)
	ADD	#<30.-5>, R3
	SOB	R1, 20$
LB922:	MOV	#L6B8A, R3		; Tile screen 3 start address
	MOV	#<512./2>, R1
LB92D:	MOV	#177777, (R3)+		; put two bytes $FF
	SOB	R1, LB92D
	MOV	L7184, R3		; get Current Room address
	MOV	(R3), R3
	JMP	@R3			; execute room procedure

; Standard room procedure (redirect from B41F)
LB937:	MOV	#LA39F, R4		; Three objects start address
	MOV	#3, R1
LB93D:	MOVB	#4, LB951
	TSTB	(R4)			; have an object here?
	BNE	LB94A
	JMP	LBA21			; no => skip to end of loop
LB94A:	PUSH	R1
	CALL	LBBAE			; set "need update" mark for object
	MOV	#2, R1
LB94F:	MOVB	4(R4), R0
LB951 = LB94F + 2
	CLR	R2
	CMPB	R0, #3
	BHIS	LB95F
	MOV	#-30., R2
	DECB	6(R4)			; decrement object Y
LB95F:	CMPB	R0, #6
	BLO	LB969
	MOV	#30., R2
	INCB	6(R4)			; increment object Y
LB969:	CMPB	R0, #1
	BEQ	LB98D
	CMPB	R0, #4
	BEQ	LB98D
	CMPB	R0, #7
	BEQ	LB98D
	DEC	R2
	DECB	7(R4)			; decrement object X
	CMPB	R0, #3
	BEQ	LB98D
	TSTB	R0
	BEQ	LB98D
	CMPB	R0, #6
	BEQ	LB98D
	INC	R2
	INC	R2
	INCB	7(R4)			; increment object X
	INCB	7(R4)
LB98D:	MOV	2(R4), R3
	ADD	R2, R3
	MOV	R3, 2(R4)
	MOVB	6(R4), R0		; get object Y
	CMPB	R0, #-1
	BEQ	LBBA7
	CMPB	R0, #17.
	BEQ	LBBA7
	MOVB	7(R4), R0		; get object X
	CMPB	R0, #30.
	BEQ	LBBA7
	CMPB	R0, #-1
	BEQ	LBBA7
	MOV	R3, R5
	ADD	#L6590, R5		; Tile screen 0 start address
	CMPB	#144, (R5)		; $64
	BLO	LBAD5
	MOV	R3, R5
	ADD	#L6B8A, R5		; Tile screen 3 start address
	CMPB	#377, (R5)
	BEQ	LB9DA
	MOVB	L71CF, R0
	CMPB	R0, #102
	BHIS	LBAD5
	ADD	#102, R0
	MOVB	R0, L71CF
	BR	LBAD5
LB9DA:	MOV	R3, R5
	ADD	#L6D88, R5		; Tile screen 4 start address
	CMPB	#377, (R5)
	BEQ	LB9F9
	CMPB	#9., L7346		; Guard state = 9 dead ?
	BEQ	LBAD5
	MOVB	#9., L7346		; set Guard state = 9 dead
	MOV	#1, R1
	CALL	LB4DE			; Increase PAY value by 100 - Guard killed by weapon
	BR	LBAD5
LB9F9:	INCB	LB951
	DEC	R1
	BNE	LB94F
	ADD	#L698C, R3		; Tile screen 2 start address
	CMPB	(R3), #310		; $C8
	BHIS	LBA14
	MOV	#20., R1
	CALL	L9DD9			; Decrease Energy by B = 20.
	BR	LBAD5
LBA14:	MOVB	(R4), R0
	MOVB	R0, (R3)
	MOV	#1, R5
	XOR	R5, R0
	MOVB	R0, (R4)
	CALL	LBBAE			; set "need update" mark for object
;
LBA20:	POP	R1
LBA21:	ADD	#8., R4			; next object record
	DEC	R1
	BEQ	LBA2A
	JMP	LB93D
;
LBA2A:	MOV	#<L678E+165.>, R3	; !!MUT-ARG!! Tile screen 1 + 5 rows + 15.
LBA2B = LBA2A + 2
	MOV	#3, R1
	MOV	#1, R0
LBA2F:	MOV	R3, R5
	MOVB	R0, (R5)+
	MOVB	R0, (R5)+
	MOVB	R0, (R5)+
	ADD	#30., R3
	SOB	R1, LBA2F
;
	CALL	LB148			; Draw tile map on the screen
	;TODO: Restore drawing of Dog and Guard tiles
	TSTB	LBAB2
	BNE	LBA52
	JMP	LB77B			; => Game loop start

; Draw Explosion image on the screen and make some noise
LBA52:
	;TODO
	JMP	LB77B			; => Game loop start

LBAB2:	.BYTE	0	; ??
	.EVEN

LBAD5:
	;TODO

	BR	LBA20

LBBA7:	CLRB	(R4)			; delete the object
	BR	LBA20

; Set "need update" mark for object R4
LBBAE:	MOV	2(R4), R3		; get object position
	ADD	#L678E, R3		; Tile screen 1 start address
	MOVB	#1, (R3)
	RETURN

; Set update flags for Ninja, 6x7 tiles
LBBBB:	MOV	L9C42, R3		; get Ninja position in tilemap
	ADD	#L678E, R3		; Tile screen 1 start address
	MOV	#7, R1			; 7 rows
	MOV	#001, R0		; "need to update" mark
10$:	MOVB	R0, (R3)+		; 6 columns
	MOVB	R0, (R3)+
	MOVB	R0, (R3)+
	MOVB	R0, (R3)+
	MOVB	R0, (R3)+
	MOVB	R0, (R3)
	ADD	#<30.-5>, R3		; next row
	SOB	R1, 10$			; continue by rows
	RETURN

; Movement handler: Ninja punching
LBBD4:	CALL	LBBDF			; Read input
	BIT	#20, R0			; check FIRE bit
	BEQ	LBBDC
	JMP	LB8D0			; => Update Ninja on tilemap
LBBDC:	JMP	LC226			; no FIRE => Ninja standing

; Read Input
LBBDF:	TSTB	@#177560		; do we have an unprocessed key?
	BPL	K41276			; no => jump
	MOVB	@#177562, R0		; get the key
	MOV	#KEYMAP, R3		; table address
	MOV	#5., R1			; table size
K41256:	CMPB	(R3)+, R0		; <  matches the key?
	BNE	K41270			; |  no => jump
	MOVB	(R3), R0		; |  get the result byte
	BR	K41300			; |  break the loop
K41270:	INC	R3			; |  to next key probe
	SOB	R1, K41256		; repeat
K41276:	CLR	R0			; not found - result is empty
K41300:	MOVB	R0, L7232		; store input bits
	RETURN

; Game controls
;  7   6   5   4   3   2   1   0
;              Fr  Up  Dn  Lt  Rt
;
; Key mappings
KEYMAP:	.BYTE	070, 010		; '8' - up
	.BYTE	062, 004		; '2' - down
	.BYTE	064, 002		; '4' - left
	.BYTE	066, 001		; '6' - right
	.BYTE	065, 020		; '5' - fire
;	.BYTE	061, 000		; '1' - up + left
;	.BYTE	063, 000		; '3' - up + right
;	.BYTE	067, 000		; '7' - down + fire
;	.BYTE	071, 000		; '9' - down + fire
	.EVEN

LBC0D:
; Clear the screen
	MOV	#GAMESC, R1
	CALL	PRINT
	CALL	PAUSE
; Prepare screen background for title picture
	;TODO

LBC13:
	;TODO

; Show the title picture
LBC38:	CALL	L6289			; Show title picture (two ninjas)

LBC3B:
	;TODO

	JMP	LDF37

; Movement handler: Ninja standing
LBC55:
; Increase Energy if needed
	MOV	#LB5C5, R3		; Ninja standing counter address
	DECB	(R3)			; decrease counter
	BNE	LBC76
	MOVB	#2, (R3)		; reload the counter
	CALL	LB83C			; Increase Energy a bit
; Move the head (idle animation)
LBC76:	MOV	#LB2FD, R3		; address for head movement counter
	INCB	(R3)			; increase counter
	BNE	LBC98			; not zero => skip head animation
	MOVB	#190., (R3)		; reset counter (how often head moves)
LBC7E:	MOV	#<LD486+8.>, R2
	MOV	#364, R5
	MOVB	(R2), R0
	XOR	R5, R0			; toggle tile with $F4
	MOVB	R0, (R2)+		; set head tile
	MOVB	(R2), R0
	XOR	R5, R0			; toggle tile with $F4
	MOVB	R0, (R2)		; set head tile
	;MOV	#<LD486+15.>, R2
	;MOVB	(R2), R0
	;XOR	R5, R0
	;MOVB	R0, (R2)
LBC98:	;CMPB	#210., (R3)
	;BEQ	LBC7E
; Check for suicide key combination
LBC9D:
	;TODO

LBCB6:	CALL	LC5A3			; Check for falling
	BNE	LBCBC
	JMP	LC643			; => Ninja falling
LBCBC:	MOV	#LB595, R3
	TSTB	(R3)
	BEQ	LBCC4
	DECB	(R3)
LBCC4:	CALL	LBBDF			; Read Input
	BIT	#20, R0			; check FIRE bit
	BNE	LBCCC			; FIRE =>
	JMP	LBDDD
; FIRE pressed, ninja standing
LBCCC:	MOV	#LB595, R3		; action cooldown counter address
	TSTB	(R3)			; check if counter is 0
	BEQ	LBCD4
	JMP	LBDB2			; not zero =>
LBCD4:	MOVB	#5, (R3)		; reset cooldown (5 ticks until next action)
	MOVB	LB84C, R1		; get Object tile
	CMPB	#143, R1		; Object tile = $63 Console ?
	BEQ	LBD33			; yes => execute the object procedure
	MOV	L9C42, R3		; get Ninja position in tilemap
	ADD	#<L6590+217.>, R3	; + Tile screen 0 + 7 row + 7
	CMPB	#234, (R3)		; $9C ?
	BNE	LBCF3			; no =>
	CMPB	#2, LB5C6		; Time mode = BOMB ticking mode?
	BEQ	LBD37			; yes =>
	BR	LBCF7
LBCF3:	TSTB	R1			; Object tile = nothing?
	BEQ	LBD37			; nothing =>
LBCF7:	CLR	R0
	BISB	LB850, R0		; get HELD tile
	MOV	LB84A, R2		; get Object address + 4
	MOVB	R0, (R2)		; set Object tile = held
	DEC	R2			; Object address + 3
	TSTB	R0			; held nothing?
	BEQ	LBD08			; nothing =>
	SUB	#306, R0		; $C6
	ASR	R0
LBD08:	MOVB	R0, (R2)		; set Object item
	MOVB	#9., <LD256+<7*8.>+3>	; set item in Object #7 in Table of objects D256
	MOV	R1, R0
	MOVB	R0, LBD7A		; set HELD tile
	CMPB	#324, R0		; $D4 diskette ?
	BEQ	LBD17
	JMP	LB8D0			; => Update Ninja on tilemap
LBD17:	MOV	#LB5C6, R3		; Time mode address
	TSTB	(R3)			; 0 = time ticking ?
	BEQ	LBD1F			; yes =>
	JMP	LB8D0			; => Update Ninja on tilemap
; We've got the disk, so stop the time and give a bonus
LBD1F:	MOVB	#1, (R3)		; set Time mode = time stopped
	MOV	#400., R3
	CALL	LB371			; Play melody
	MOV	#50., R1
	CALL	LB4DE			; Increase PAY value by 5000
	JMP	LB8D0			; => Update Ninja on tilemap

; "BOMB" message
LBD2F:	.ASCII	/BOMB/

; FIRE pressed on Console object
LBD33:	MOV	LB84D, R3		; get object procedure address
	JMP	@R3			; execute the object procedure

; Fire pressed, Ninja standing, no object nearby
LBD37:	MOV	#LA39F, R3
	TSTB	(R3)
	BNE	LBDB2
	MOVB	LB850, R0		; get HELD tile
	BEQ	LBDB2			; nothing =>
	CMPB	#324, R0		; $D4 diskette ?
	BEQ	LBDB2
	CMPB	#326, R0		; $D6 bomb ?
	BEQ	LBDB2
; Have throwable item in HELD, so throw it away
	MOVB	R0, (R3)
	MOV	L9C42, R3		; get Ninja position in tilemap
	ADD	#61., R3		; + 2 rows + 1
	MOVB	L9C41, R1		; get Ninja X
	INC	R1
	TSTB	L7239			; check Ninja direction
	BEQ	LBD6A			; left =>
	ADD	#3, R1			; Ninja X + 1 + 3
	ADD	#3, R3			; Ninja position + 3
LBD6A:	MOVB	R1, LA3A5		; set thrown object X
	MOV	R3, LA3A0		; set thrown object position
	MOVB	L9C40, R0		; get Ninja Y
	ADD	#2, R0
	MOVB	R0, LA3A4		; set thrown object Y
LBD79:	MOV	#310, R0		; !!MUT-ARG!! $C8
LBD7A = LBD79 + 2	; HELD tile
	MOVB	R0, LA39F
	CLRB	LBD7A
	MOV	#3, R1
	TSTB	L7239			; check Ninja direction
	BEQ	LBD8D			; left =>
	ADD	#2, R1
LBD8D:	MOVB	R1, LA3A3
	MOVB	L7232, R0		; get Input bits
	BIT	#10, R0			; check UP bit
	BEQ	LBD9B
	ADD	#-3, R1
LBD9B:	BIT	#4, R0			; check DOWN bit
	BEQ	LBDA2
	ADD	#3, R1
LBDA2:	MOVB	R1, LA3A2
	CALL	LF9F9
	MOV	#LD504, R2		; Sprite Ninja/Guard punching
	JMP	LBFB0			; Set movement handler = HL, Ninja sprite = DE

;NOTE: LBDAF now an alias for LC226	; => Ninja standing

; ?? Ninja action?
LBDB2:	MOV	L9C42, R3		; get Ninja position in tilemap
	MOV	#<L6D88+34.>, R2	; Tile screen 4 + 34, for right
	TSTB	L7239			; check Ninja direction
	BNE	LBDC2			; right =>
	MOV	#<L6D88+31.>, R2	; Tile screen 4 + 31, for left
LBDC2:	ADD	R2, R3			; now R3 = address in Guard tilemap
	CMPB	#377, (R3)		; empty tile?
	BEQ	LBDD4			; yes =>
	MOVB	#9., L7346		; set Guard state = $09 dead
	CALL	LB596
	MOV	#5, R1			; 5 hundreds
	CALL	LB4DE			; Increase PAY value by 500 - Guard killed
LBDD4:	MOV	#LBBD4, R3		; Movement handler address
	MOV	#LD504, R2		; Sprite Ninja/Guard punching
	JMP	LBFB0			; Set movement handler = HL, Ninja sprite = DE

LBDDD:	BIT	#10, R0			; bit 3 - up
	BNE	LBDE2			; yes =>
	JMP	LBFBA
; UP pressed
LBDE2:	MOV	L9C42, R2		; get Ninja position in tilemap
	MOV	#<L6590+30.>, R3	; Tile screen 0 + 1 row
	ADD	R2, R3
	CMPB	#332, (R3)		; = $DA ?
	BEQ	LBDF0
	JMP	LBF7B
LBDF0:	MOVB	#11., L7343		; set counter = 11.
	MOV	#<L6590+44.>, R3	; Tile screen 0 + 1 row + 14.
	MOV	R3, LBE0E
	MOV	R3, LBE1D
	MOV	#<L678E+302.>, LBA2B	; Tile screen 1 + 10. rows + 2
	MOV	#LBE0D, R3		; Movement handler
	MOV	#LD486, R2		; Sprite Ninja/Guard standing
	JMP	LBFB0			; Set movement handler = R3, Ninja sprite = R2

; Movement handler: opening the roof in the helicopter room
LBE0D:	MOV	#<L6590+33.>, R3	; !!MUT-ARG!!
LBE0E = LBE0D + 2
	MOV	#1, R0			; tile / "need to update" flag
	MOVB	R0, (R3)		; put background tile
	DEC	R3
	MOV	R3, LBE0E
	ADD	#511., R3		; R3 = address in Tile screen 1
	MOVB	R0, (R3)		; put "need to update" flag
LBE1C:	MOV	#<L6590+55.>, R3
LBE1D = LBE1C + 2
	MOVB	R0, (R3)+		; put background tile
	MOV	R3, LBE1D
	ADD	#509., R3		; R3 = address in Tile screen 1
	MOVB	R0, (R3)		; put "need to update" flag
	MOV	#L7343, R3		; counter address
	DECB	(R3)			; decrease counter
	BEQ	LBE30
	JMP	LB8D0			; => Update Ninja on tilemap
LBE30:	MOVB	#20., (R3)		; reset the counter
	MOV	#<L6590+458.>, R3
	MOV	#<L678E+458.>, R2
	MOV	#10., R1
LBE3A:	MOVB	R0, (R3)+
	MOVB	R0, (R2)+
	SOB	R1, LBE3A
	MOV	#272., L9C42		; set Ninja position in tilemap
	MOV	#<L678E+210.>, R3	; Tile screen 1 + 7 rows
	MOV	#210., R1		; 7 rows
LBE4F:	MOVB	R0, (R3)+
	SOB	R1, LBE4F
	MOV	#LC094, R3		; Movement handler (helicopter?)
	MOV	#LC0E6, R2		; Empty sprite
LBE57:	JMP	LBFB0			; Set movement handler = R3, Ninja sprite = R2

; Ninja sit, and then fall and DIE
LBE5A:	MOV	#LBE63, R3		; Movement handler: Ninja dead
	MOV	#LD558, R2		; Sprite Ninja sitting
	JMP	LBFB0			; Set movement handler = R3, Ninja sprite = R2

; Movement handler (B8CE handler): Ninja dead
LBE63:	MOV	#000207, L9DD9		; set instruction = RETURN
	MOV	#LBEB3, R3		; Movement handler: Game Over
	MOV	#LA0B5, R2		; Sprite Ninja dead
	JMP	LBFB0			; Set movement handler = R3, Ninja sprite = R2

; Time is out
LBE71:	CMPB	LB5C6, #2		; Time mode = BOMB ticking mode?
	BEQ	LBE80			; yes =>
	MOV	#LBF35, LBEB4		; set wo-line Game Over message = "TIME OUT" / "MISSION TERMINATED"
	BR	LBE63			; => Ninja dead
; BOMB time is out, BOMB explodes
LBE80:
	HALT
	;TODO
	PUSH	R3
; Saboteur is dead
LBEAA:	POP	R3
	MOV	#LBF58, LBEB4		; set two-line Game Over message = "SABOTEUR DEAD" / "MISSION FAILURE"
	BR	LBE63			; => Ninja dead

; Movement handler: Game Over
LBEB3:	MOV	#LBEEF, R3		; !!MUT-ARG!! two-line message address
LBEB4 = LBEB3 + 2
	MOV	#<SCREEN+<1200*3.>+12.>, R2
	MOV	#15., R1
	CALL	LAED1			; Print string 1st line
	MOV	#<SCREEN+<1200*5.>+10.>, R2
	MOV	#20., R1
	CALL	LAED1			; Print string 1st line
;
	CALL	LF9B9			; Pause, then wait for any key pressed

	;TODO
	JMP	LBC0D			; => Title picture and music, then go to Main menu

LBEEF:	.ASCII	/     SEPUKU    /
	.ASCII	/  MISSION ABORTED   /
LBF12:	.ASCII	/     ESCAPE    /
	.ASCII	/ MISSION SUCCESSFUL /
LBF35:	.ASCII	/    TIME OUT   /
	.ASCII	/ MISSION TERMINATED /
LBF58:	.ASCII	/ SABOTEUR DEAD /
	.ASCII	/  MISSION FAILURE   /
	.EVEN

; UP pressed (continued, see BDE2)
LBF7B:	MOV	#<L6590+2>, R3		; Tile screen 0 + 2
	ADD	R2, R3
	CMPB	#144, (R3)		; $64 ?
	BLO	LC16E			; => Update Ninja on tilemap
	INC	R3
	CMPB	#144, (R3)		; $64 ?
	BLO	LC16E			; => Update Ninja on tilemap
	MOVB	#3, L7343		; set counter = 3
	MOVB	L7232, R0		; get Input bits
	TSTB	L7239			; check Ninja direction
	BEQ	LBFA0			; left =>
	BIT	#1, R0			; check RIGHT bit
	BEQ	LBF9E
	CALL	LC4E8
LBF9E:	BR	LBFA5
LBFA0:	BIT	#2, R0			; check LEFT bit
	BEQ	LBFA5
	CALL	LC4E8
LBFA5:	MOV	#LC339, R3		; Movement handler: Ninja jumping
	MOVB	#2, L7343		; set counter = 2
	MOV	#LD4B0, R2		; Sprite Ninja/Guard jumping
;
; Set movement handler = R3, set Ninja sprite = R2
LBFB0:	MOV	R3, LB8CE		; set movement handler
	MOV	R2, L7186		; set Ninja sprite address
	JMP	LB8D0			; => Update Ninja on tilemap

LBFBA:	BIT	#4, R0			; bit 2 - down
	BEQ	LC13D			; no =>
; DOWN pressed
LBFBF:	MOV	L9C42, R3		; get Ninja position in tilemap
	ADD	#<L6590+212.>, R3	; + Tile screen 0 + 7 rows + 2
	CALL	LC392			; Check if tile is a ladder
	BEQ	LC12E			; => Ninja on ladder
;
; Switch Ninja to sitting
LBFCC:	MOV	#LC22F, R3		; Movement handler: Ninja sitting
	MOV	#LD558, R2		; Sprite Ninja sitting
	BR	LBFB0			; Set movement handler = HL, Ninja sprite = DE

; Escaped; clear screen, show final messages, then Game Over
LBFD5:	MOV	#10., R1
	CALL	LB4DE			; Increase PAY value by 1000 - Escape by Helicopter
	CMPB	#324, LBD7A		; HELD tile = $D4 diskette ?
	BNE	LC04A
	MOV	#50., R1
	CALL	LB4DE			; Increase PAY value by 5000
	;TODO: Clear whole screen
	;TODO

LC04A:	CMPB	#2, LB5C6		; Time mode = BOMB ticking mode ?
	BNE	LC056			; no =>
	MOV	#100., R1
	CALL	LB4DE			; Increase PAY value by 10000 - Escape with Disk and Bomb
LC056:	MOV	#LBF12, LBEB4		; "ESCAPE" / "MISSION SUCCESSFUL"
	;NOP
	;NOP
	;NOP
	JMP	LBEB3			; => Game Over

;NOTE: Messages LC062 moved from here

; ?? Movement handler (helicopter?)
LC094:	DECB	#L7343			; decrease counter
	BEQ	LBFD5			; => zero => Escaped; final messages, then Game Over
	;TODO

	;HALT
	;TODO
	JMP	LB8D0			; => Update Ninja on tilemap

; Ninja on ladder
LC12E:	MOV	#LC3D9, LB8CE		; Movement handler for Ninja on ladder
	MOV	#LD52E, L7186		; Sprite Ninja on ladder
	JMP	LC498			; => Move down one tile

LC13D:	BIT	#2, R0			; bit 1 - left
	BEQ	LC154			; no =>
; LEFT pressed
	MOV	#L7239, R3		; Ninja direction address
	TSTB	(R3)			; left?
	BEQ	LC14B
	CLRB	(R3)			; change direction to left
	BR	LC16E			; => Update Ninja on tilemap
LC14B:	MOV	#LC24B, R3		; Movement handler address
	MOV	#LD3DE, R2		; Sprite Ninja/Guard walking 1
	BR	LBFB0			; Set movement handler = HL, Ninja sprite = DE

LC154:	BIT	#1, R0			; bit 0 - right
	BEQ	LC16E			; no =>
; RIGHT pressed
	MOV	#L7239, R3		; Ninja direction address
	TSTB	(R3)			; left?
	BNE	LC162			; no =>
	INCB	(R3)			; change direction to right
	BR	LC16E			; => Update Ninja on tilemap
LC162:	MOV	#LC1B6, LB8CE		; set Movement handler address
	MOV	#LD3DE, L7186		; Sprite Ninja/Guard walking 1
LC16E:	JMP	LB8D0			; => Update Ninja on tilemap

; Movement handler - Ninja walking right
LC1B6:	MOVB	L9C41, R0		; get Ninja X
	CMPB	#24., R0		; near right edge?
	BNE	LC1BE
	JMP	LC2FA			; => Going to room at Right
LC1BE:	MOV	L9C42, R3		; get Ninja position in tilemap
	ADD	#<L6590+184.>, R3	; + Tile screen 0 + 6 rows + 4
	CMPB	#144, (R3)		; $64
	BHIS	LC1DA
	DECB	L9C40			; decrement Ninja Y - one row up
	ADD	#-30., L9C42		; Ninja position in tilemap -30.
	BR	LC20D
LC1DA:	ADD	#-29., R3
	CMPB	#144, (R3)		; $64
	BHIS	LC1EE
	CALL	LBBDF			; Read Input
	BIT	#1, R0			; check RIGHT bit
	BEQ	LC226			; => Ninja standing
	JMP	LB8D0			; => Update Ninja on tilemap
LC1EE:	ADD	#59., R3
	CMPB	#144, (R3)		; $64
	BLO	LC20D
	DEC	R3
	CMPB	#144, (R3)		; $64
	BLO	LC20D
	ADD	#30., L9C42		; Ninja position in tilemap +30.
	MOV	#L9C40, R3		; Ninja Y address
	INCB	(R3)			; one row down
	CMPB	#10., (R3)		; at the room bottom?
	BNE	LC20D			; no =>
	JMP	LC604			; => Going to room Down from current
LC20D:	INCB	L9C41			; move one tile to right
	INC	L9C42			; increment Ninja position in tilemap
	CALL	LC5A3			; Check for falling
	BNE	LC21E			; not falling =>
	JMP	LC643			; => Ninja falling
LC21E:	CALL	LBBDF			; Read Input
	BIT	#1, R0			; check RIGHT bit
	BNE	LC2BB			; RIGHT pressed =>

; Ninja standing
LC226:	MOV	#LBC55, R3		; Movement handler: Ninja standing
LBDAF = LC226
	MOV	#LD486, R2		; Sprite Ninja/Guard standing
	JMP	LBFB0			; Set movement handler = R3, Ninja sprite = R2

; Movement handler (B8CE handler): Ninja sitting
LC22F:	CALL	LBBDF			; Read input
	BIT	#4, R0			; check DOWN bit
	BEQ	LC226			; DOWN key released => stand up
; DOWN still pressed
LC239:	MOV	L9C42, R3		; get Ninja position in tilemap
	ADD	#<L6F86+182.>, R3	; Tile screen 5 + 182.
	CMPB	#014, (R3)
	BNE	LC248
	MOV	#2, R1
	CALL	L9DD9			; => Decrease Energy by 2
LC248:	BR	LC16E			; => Object procedure

; Movement handler - Ninja walking left
LC24B:	TSTB	L9C41			; Ninja X at very left?
	BEQ	LC319			; yes => Going to room at Left
LC253:	MOV	L9C42, R3		; get Ninja position in tilemap
	ADD	#<L6590+181.>, R3	; + Tile screen 0 + 6 rows + 1
	CMPB	#144, (R3)		; $64
	BHIS	LC26F
	DECB	L9C40			; moving one row up
	ADD	#-30., L9C42		; Ninja position in tilemap -30.
	BR	LC2A2
LC26F:	ADD	#-31., R3
	CMPB	#144, (R3)		; $64
	BHIS	LC283
	CALL	LBBDF			; Read Input
	BIT	#2, R0			; check LEFT bit
	BEQ	LC226			; => Ninja standing
	JMP	LB8D0			; => Update Ninja on tilemap
LC283:	ADD	#61., R3
	CMPB	#144, (R3)		; $64
	BLO	LC2A2
	INC	R3
	CMPB	#144, (R3)		; $64
	BLO	LC2A2
	ADD	#30., L9C42		; Ninja position in tilemap +30.
	MOV	#L9C40, R3		; Ninja Y address
	INCB	(R3)			; one row down
	CMPB	#10., (R3)		; at the room bottom?
	BNE	LC2A2			; no =>
	JMP	LC604			; => Going to room Down from current
LC2A2:	DECB	L9C41			; move one tile to left
	DEC	L9C42			; decrement Ninja position in tilemap
	CALL	LC5A3			; Check for falling
	BNE	LC2B3			; not falling =>
	JMP	LC643			; => Ninja falling
LC2B3:	CALL	LBBDF			; Read Input
	BIT	#2, R0			; check LEFT bit
	BEQ	LC226			; => Ninja standing

; LEFT or RIGHT key pressed
LC2BB:	MOVB	#7, L7343		; set counter = 7
	BIT	#10, R0			; check for UP bit
	BEQ	LC2C5
	CALL	LC4E8
LC2C5:	MOVB	L733A, R0
	INC	R0			; next walking phase
	BIC	#177774, R0		; 0..3
	MOVB	R0, L733A
	ADD	R0, R0			; * 2
	MOV	R0, R3
	CLRB	LA39E
	TSTB	R0
	BNE	LC2E8
	INC	R0
	MOVB	R0, LA39E
	;TODO: Sound?

LC2E8:	MOV	L733B(R3), L7186	; sprite address from table -> Ninja sprite
	JMP	LB8D0			; => Update Ninja on tilemap

; Going to room at Right
LC2FA:	CLRB	L9C41			; set Ninja X = 0
	ADD	#-24., L9C42		; update Ninja position in tilemap
	MOV	L7184, R3		; get Current Room address
	MOV	6(R3), R3		; get Room Right address
	MOV	R3, L7184		; set Current Room address
	JMP	LB66A			; => Current Room changed

; Going to room at Left
LC319:	MOV	#24., L9C41		; set Ninja X = 24.
	ADD	#24., L9C42		; update Ninja position in tilemap
	MOV	L7184, R3		; get Current Room address
	MOV	4(R3), R3		; get Room Left address
	MOV	R3, L7184		; set Current Room address
	JMP	LB66A			; => Current Room changed

; Movement handler (B8CE handler): Ninja jumping
LC339:	DECB	L7343			; decrease counter
	BEQ	LC340
	JMP	LB8D0			; => Update Ninja on tilemap
LC340:	MOV	L9C42, R3		; get Ninja position in tilemap
	ADD	#<L6590+2>, R3		; + Tile screen 0 + 2
	TSTB	L7239			; check Ninja direction
	BNE	LC361
	MOVB	(R3), R0
	CMPB	#014, R0		; $0C
	BEQ	LC3BB
	CMPB	#012, R0		; $0A
	BEQ	LC3BB
	CMPB	#010, R0		; $08
	BEQ	LC3BB
	CMPB	#011, R0		; $09
	BEQ	LC3BB
	BR	LC368
LC361:	INC	R3
	CALL	LC392
	BEQ	LC3CF
	DEC	R3
LC368:	CALL	LC392
	BEQ	LC3C6			; => Ninja on ladder
	MOV	#<L6590+60.>, R2	; Tile screen 0 + 2 rows
	MOV	L9C42, R3		; get Ninja position in tilemap
	TSTB	L7239			; check Ninja direction
	BEQ	LC37D			; left =>
	MOV	#<L6590+65.>, R2	; Tile screen 0 + 2 rows + 5
LC37D:	CMPB	#144, (R3)		; $64
	BHIS	LC384
	JMP	LC4D0
LC384:	MOV	#LC4A7, R3		; Movement handler
	MOV	#LD4DA, R2		; Sprite Ninja/Guard jump-kick
	MOVB	#3, L7343		; set counter = 3
	JMP	LBFB0			; Set movement handler = HL, Ninja sprite = DE

; Check if tile is a ladder
LC392:	MOVB	(R3), R0		; get the tile
	MOV	#1, R1
	CMPB	#005, R0		; $05
	BEQ	LC3B7
	CMPB	#006, R0		; $06
	BEQ	LC3B7
	CMPB	#007, R0		; $07
	BEQ	LC3B7
	CMPB	#366, R0		; $F6
	BEQ	LC3B7
	CMPB	#361, R0		; $F1
	BEQ	LC3B7
	CMPB	#357, R0		; #EF
	BEQ	LC3B7
	CMPB	#355, R0		; $ED
	BEQ	LC3B7
	CMPB	#014, R0		; #0C
	BEQ	LC3B7
	CLR	R1
LC3B7:	CMPB	#1, R1			; Z = ladder
	RETURN

; Move LEFT one tile
LC3BB:	DECB	L9C41			; decrease Ninja X
	DEC	L9C42			; move one tile left

; Ninja on ladder now
LC3C6:	MOV	#LC3D9, R3		; Movement handler for Ninja on ladder
	MOV	#LD52E, R2		; Sprite Ninja on ladder
	JMP	LBFB0			; Set movement handler = HL, Ninja sprite = DE

; Move RIGHT one tile
LC3CF:	INCB	L9C41			; increase Ninja X
	INC	L9C42			; increase Ninja position in tilemap
	BR	LC3C6			; => Ninja on ladder

; Movement handler (B8CE handler): Ninja on ladder
LC3D9:	MOV	L9C42, R3		; get Ninja position in tilemap
	ADD	#<L6590+183.>, R3	; + Tile screen 0 + 6 rows + 3
	CMPB	#014, (R3)		; ladder?
	BEQ	LC3EC			; yes => Read and process Input
	DEC	R3
	CALL	LC392
	BEQ	LC3EC			; yes => Read and process Input
	JMP	LC226			; => Ninja standing
; Read and process Input
LC3EC:	CALL	LBBDF			; Read Input
	BIT	#1, R0			; check RIGHT bit
	BEQ	LC40E
; Pressed RIGHT
	MOV	L9C42, R3		; get Ninja position in tilemap
	ADD	#<L6590+184.>, R3	; + Tile screen 0 + 6 rows + 4
	CMPB	#144, (R3)		; $64
	BLO	LC42C
	ADD	#30., R3		; next row
	CMPB	#144, (R3)		; $64
	BHIS	LC42C
	MOVB	#1, L7239		; set direction = right
	JMP	LC162
; Check if LEFT pressed
LC40E:	BIT	#2, R0			; check LEFT bit
	BEQ	LC42C
; Pressed LEFT
	MOV	L9C42, R3		; get Ninja position in tilemap
	ADD	#<L6590+181.>, R3	; + Tile screen 0 + 6 rows + 1
	CMPB	#144, (R3)		; $64
	BLO	LC42C
	ADD	#30., R3		; next row
	CMPB	#144, (R3)		; $64
	BHIS	LC42C
	CLRB	L7239			; set direction = left
	JMP	LC14B
; Check if UP pressed
LC42C:	MOVB	L7232, R0		; get Input bits
	BIT	#10, R0			; check UP bit
	BEQ	LC477
; Pressed UP
	MOV	L9C42, R3		; get Ninja position in tilemap
	ADD	#<L6590+183.>, R3	; + Tile screen 0 + 6 rows + 3
	CMPB	#014, (R3)		; $0C
	BEQ	LC447
	DEC	R3
	CALL	LC392
	BNE	LC495			; => Update Ninja on tilemap
LC447:	TSTB	L9C40			; check Ninja Y
	BNE	LC44F			; top row?
	JMP	LC623			; => Going to room Up
LC44F:	ADD	#-210., R3
	CMPB	#352, (R3)		; $EA
	BEQ	LC495			; => Update Ninja on tilemap
	CMPB	#377, (R3)
	BEQ	LC495			; => Update Ninja on tilemap
	DECB	L9C40			; decrement Ninja Y - one row up
	ADD	#-30., L9C42		; Ninja position in tilemap -30.
LC467:	MOV	#1, R0
	XOR	R0, L7239		; invert Ninja direction
	JMP	LB8D0			; => Update Ninja on tilemap

; Check if DOWN pressed
LC477:	BIT	#4, R0			; check DOWN bit
	BEQ	LC495
; Pressed DOWN
	CMPB	#10., L9C40		; Ninja Y at the room bottom?
	BNE	LC483
	JMP	LC604			; => Going to room Down from current
LC483:	MOV	L9C42, R3		; get Ninja position in tilemap
	ADD	#<L6590+213.>, R3	; + Tile screen 0 + 7 rows + 3
	CMPB	#014, (R3)
	BEQ	LC498			; => Move down one tile
	DEC	R3
	CALL	LC392
	BEQ	LC498			; => Move down one tile
LC495:	JMP	LB8D0			; => Update Ninja on tilemap

; Move DOWN one tile
LC498:	INCB	L9C40			; increment Ninja Y
	ADD	#30., L9C42		; Ninja position in tilemap +30.
	BR	LC467			; => invert direction, update Ninja

; ?? Movement handler
LC4A7:	DECB	L7343			; decrease counter
	BEQ	LC4AE
	JMP	LB8D0			; => Update Ninja on tilemap
LC4AE:	MOV	L9C42, R3		; get Ninja position in tilemap
	MOV	#<L6D88+65.>, R2	; Tile screen 4 + 2 rows + 5
	TSTB	L7239			; check Ninja direction
	BNE	LC4BE			; right =>
	MOV	#<L6D88+60.>, R2	; Tile screen 4 + 2 rows
LC4BE:	ADD	R2, R3
	CMPB	#377, (R3)		; $FF ?
	BEQ	LC4D0			; yes =>
	MOVB	#9., L7346		; set Guard state = $09 dead
	CALL	LB596
	MOV	#5, R1
	CALL	LB4DE			; Increase PAY value by 500 - Guard killed by punch/kick

LC4D0:	MOV	#LC4DE, R3		; Movement handler address
	MOV	#LD4B0, R2		; Sprite Ninja/Guard jumping
	MOVB	#1, L7343		; set counter = 1
	JMP	LBFB0			; Set movement handler = HL, Ninja sprite = DE

; ?? Movement handler
LC4DE:	DECB	L7343			; decrease counter
	BEQ	LC4E5
	JMP	LB8D0			; => Update Ninja on tilemap
LC4E5:	JMP	LC226			; => Ninja standing

LC4E8:	CALL	LC57B			; Check for ??
	BEQ	LC4EC
	RETURN
LC4EC:	POP	R3
	MOV	#LC4F6, R3		; Movement handler address
	MOV	#LD5AC, R2		; Sprite Ninja jumping 3
	JMP	LBFB0			; Set movement handler = HL, Ninja sprite = DE

; Movement handler (used in initial room)
LC4F6:	CALL	LC57B			; Check for ??
	BEQ	LC504
	MOV	#3, R1
	CALL	L9DD9			; Decrease Energy by 3
	JMP	LC226			; => Ninja standing
LC504:	MOV	#LC50D, R3		; Movement handler address
	MOV	#LD5D6, R2		; Sprite Ninja jumping 4
	JMP	LBFB0			; Set movement handler = HL, Ninja sprite = DE

; Movement handler ??
LC50D:	MOV	#L9C41, R3		; Ninja X address
	TSTB	L7239			; Ninja direction = left ?
	BNE	LC56C			; no =>
	TSTB	(R3)			; Ninja X = 0 ?
	BNE	LC51D			; no =>
	JMP	LC319			; yes => Going to room at Left
LC51D:	DECB	(R3)			; decrease Ninja X
	DEC	L9C42			; decrease Ninja position in tilemap
LC525:	CALL	LC57B			; Check for ??
	BNE	LC533			; falling =>
	DECB	L7343			; decrease counter
	BEQ	LC538
	JMP	LB8D0			; => Update Ninja on tilemap
;LC531:	BR	LC538
LC533:	MOV	#4, R1
	CALL	L9DD9			; Decrease Energy by 4
LC538:	MOV	#<L678E-388.>, R2
	MOV	#3, R1
LC53D:	MOV	L9C42, R3		; get Ninja position in tilemap
	ADD	R2, R3
	CMPB	#144, (R3)		; $64 ?
	BHIS	LC558
LC546:	DECB	L9C40			; decrease Ninja Y
	ADD	#-30., L9C42		; Ninja position in tilemap -30
	BR	LC53D
LC558:	INC	R3
	CMPB	#144, (R3)		; $64 ?
	BLO	LC546
	ADD	#30., R3
	MOV	R2, R0			; EX DE,HL
	MOV	R3, R2
	MOV	R0, R3
	SOB	R1, LC53D
	MOV	#LC5A0, R3		; Movement handler: switch Ninja to standing
	MOV	#LD5AC, R2		; Sprite Ninja jumping 3
	JMP	LBFB0			; Set movement handler = HL, Ninja sprite = DE
; Ninja direction = right
LC56C:	CMPB	#24., (R3)		; Ninja X = 24. ?
	BNE	LC571
	JMP	LC2FA			; => Going to room at Right
LC571:	INCB	(R3)			; increase Ninja X
	INC	L9C42			; increase Ninja position in tilemap
	BR	LC525

; Check for ??
LC57B:	MOVB	L7239, R0		; get Ninja direction: 0/1
	MOV	R0, R3
	ADD	R3, R3
	ADD	R3, R3
	ADD	R3, R0			; * 5
	ADD	L9C42, R3		; + Ninja position in tilemap
	ADD	#L6590, R3		; + Tile screen 0 start address
	CLR	R2
	MOV	#4, R1			; counter
LC596:	CMPB	#144, (R3)
	BHIS	LC59A
	INC	R2
LC59A:	ADD	#30., R3		; lower one row
	SOB	R1, LC596
	TST	R2			; NZ: falling, Z: not falling
	RETURN

; Switch Ninja to standing (redirect)
;LC5A0:	JMP	LC226			; => Ninja standing
LC5A0 = LC226

; Check for falling
LC5A3:	MOV	L9C42, R3		; get Ninja position in tilemap
	ADD	#211., R3		; + 7 rows + 1
	ADD	#L6590, R3		; Tile screen 0 start address
	MOVB	L7239, R2		; get Ninja direction: 0/1
	ADD	R2, R3
	MOV	#3, R1
	CLR	R2
LC5BB:	CMPB	#144, (R3)		; $64
	BHIS	LC5C0
	INC	R2
LC5C0:	INC	R3
	SOB	R1, LC5BB
	TST	R2			; Z = falling, NZ = not falling
	RETURN

; Movement handler: Ninja falling down
LC5C6:	ADD	#30., L9C42		; Ninja position in tilemap +30.
	INCB	L755B			; increase falling counter
	MOV	#L9C40, R3		; Ninja Y address
	INCB	(R3)			; increase Ninja Y
	CMPB	#10., (R3)		; at room bottom?
	BEQ	LC604			; => Going to room Down from current
	MOV	L9C42, R3		; get Ninja position in tilemap
	ADD	#<L6590+212.>, R3	; + Tile screen 0 + 7 rows + 2
	CMPB	#144, (R3)
	BLO	LC5EE
	INC	R3
	CMPB	#144, (R3)
	BLO	LC5EE
	JMP	LB8D0			; => Update Ninja on tilemap

; Ninja hit somehting after falling
LC5EE:	MOVB	#1, LA39E
	MOV	#L755B, R3		; falling counter address
	MOV	(R3), R1		; get counter value
	CLR	(R3)
	CALL	L9DD9			; Decrease Energy by R1
	MOV	#50., R1
	CALL	LB59E
	JMP	LBFCC			; => Ninja sitting now

; Going to room Down from current
LC604:	CLRB	L9C40			; set Ninja Y = 0
	ADD	#-300., L9C42		; Ninja position in tilemap -10 rows
	MOV	L7184, R3		; get Current Room address
	MOV	12(R3), R3		; get Room Down address
	MOV	R3, L7184		; set Current Room address
	JMP	LB66A			; => Current Room changed

; Going to room Up from current
LC623:	MOVB	#10., L9C40		; set Ninja Y = 10
	ADD	#300., L9C42		; Ninja position in tilemap +10 rows
	MOV	L7184, R3		; get Current Room address
	MOV	10(R3), R3		; get Room Up address
	MOV	R3, L7184		; set Current Room address
	JMP	LB66A			; => Current Room changed

; Ninja falling
LC643:	MOV	#LC5C6, R3		; Movement handler address: Ninja falling
	MOV	#LD582, R2		; Sprite Ninja falling
	JMP	LBFB0			; Set movement handler = HL, Ninja sprite = DE

; Room 791E (room with pier) initialization
LC64C:	MOV	#LC65A, R3
	MOV	#<L6590+220.>, R2	; = $6590 (Tile screen 0) + 220.
	MOV	#17., R1
LC655:	MOVB	(R3)+, (R2)+		; copy bytes to Background
	SOB	R1, LC655
	JMP	LB724			; => Finish room initialization
LC65A:	.BYTE	343,343,343,366,366,343,343,343
	.BYTE	366,366,343,343,343,343,343,343
	.BYTE	343
	.EVEN

LC66B:	; Guard data for rooms 7C9C/92EF
	.BYTE	016,000,016,000,004,000

; Room 93DF/947C (room right from Train) initialization
LC671:	MOV	#L947C, <L7C9C+4>	; set "room to left" for room 7C9C
	MOV	#L93DF, <L7C9C+6>	; set "room to right" for room 7C9C
	MOV	#154, R0		; $6C tile for "1" sign
	BR	LC68F

; Room 982B initialization
LC681:	MOV	#L9A1E, <L7C9C+4>	; set "room to left" for room 7C9C
	MOV	#L982B, <L7C9C+6>	; set "room to right" for room 7C9C
	MOV	#165, R0		; $75 tile for "2" sign
; Fill 3x3 block with tile for "1"/"2" sign
LC68F:	MOV	#<L7D0D+19.>, R3	; address in 7D0D sprite
	MOV	#3, R1			; 3 rows
LC697:	MOVB	R0, (R3)+
	INC	R0
	MOVB	R0, (R3)+
	INC	R0
	MOVB	R0, (R3)
	INC	R0
	ADD	#4, R3
	SOB	R1, LC697
	JMP	LB724			; => Finish room initialization

; Room 7C9C procedure (tunnel Train)
LC6A5:	CMPB	#12., L9C41		; Ninja X = 12 ?
	BNE	LC6DF			; => Standard room procedure
	MOVB	#75., L7343		; set counter = 75.
	MOV	L9C42, R2		; get Ninja position in tilemap
	MOVB	L9C41, R1		; get Ninja X
	INC	R1
	INC	R2
	MOV	#LC70C, R3		; Movement handler: Train moving right
	TSTB	L7239			; check Ninja direction
	BNE	LC6CD			; right =>
	MOV	#LC6E2, R3		; Movement handler: Train moving left
	DEC	R1
	DEC	R1
	DEC	R2
	DEC	R2
LC6CD:	MOVB	R1, L9C41		; set Ninja X
	MOV	R2, L9C42		; set Ninja position in tilemap
	MOV	#LD486, L7186		; Sprite Ninja/Guard standing
	MOV	R3, LB8CE		; set Movement handler
LC6DF:	JMP	LB937			; => Standard room procedure

; Movement handler (B8CE handler): Train moving left
LC6E2:	MOV	#2, R4
10$:	MOV	#<L6590+480.>, R2
	MOV	#<L6590+479.>, R3
	MOV	#29., R1
	MOVB	(R3), R0		; store tile from right
20$:	MOVB	-(R3), -(R2)
	SOB	R1, 20$
	MOVB	R0, (R3)		; put the tile at left
	SOB	R4, 10$

LC6F5:	MOV	#<L678E+450.>, R3
	MOV	#15., R1
30$:	MOV	#000401, (R3)+		; two bytes 001
	SOB	R1, 30$
	DECB	L7343			; decrease counter
	BNE	LC709
	JMP	LC226			; => Ninja standing
LC709:	JMP	LB8D0			; => Update Ninja on tilemap

; Movement handler (B8CE handler): Train moving right
LC70C:	MOV	#2, R4
10$:	MOV	#<L6590+450.>, R2
	MOV	#<L6590+451.>, R3
	MOV	#29., R1
	MOVB	(R2), R0		; store tile from left
20$:	MOVB	(R3)+, (R2)+
	SOB	R1, 20$
	MOVB	R0, (R2)		; put the tile at right
	SOB	R4, 10$
	BR	LC6F5

; Table of 35. records, 2 bytes each, see LB851
LD210:	.BYTE	004,316,011,143,011,143,011,143,011,143,011,143,011,143,011,324
	.BYTE	005,320,005,320,005,320,006,322,010,326,002,312,003,314,005,320
	.BYTE	005,320,005,320,003,314,002,312,002,312,003,314,002,312,006,322
	.BYTE	002,312,006,322,002,312,003,314,003,314,003,314,004,316,004,316
	.BYTE	004,316,004,316,004,316

; Table ?? objects, 35. records, 8. bytes each
LD256:	.WORD	004562		; Object 00: Brick
	.BYTE	130,004,316, 0
	.WORD	0
LD25D:	.WORD	000324		; Object 01: Console in room 80F6
	.BYTE	174,011,143, 0
	.WORD	LB320
LD264:	.WORD	000324		; Object 02: Console in room 99A6
	.BYTE	175,011,143, 0
	.WORD	LB32A
LD26B:	.WORD	000324		; Object 03: Console in room 92A7
	.BYTE	176,011,143, 0
	.WORD	LB348
LD272:	.WORD	000324		; Object 04: Console in room 92EF
	.BYTE	177,011,143, 0
	.WORD	LB334
LD279:	.WORD	000324		; Object 05: Console in room 9005
	.BYTE	200,011,143, 0
	.WORD	LB33E
LD280:	.WORD	005122		; Object 06
	.BYTE	037,011,143, 0
	.WORD	LB8D0
LD287:	.WORD	000331		; Object 07: Diskette
	.BYTE	234,011,324, 0
	.WORD	0
LD28E:	.WORD	000013		; Object 08: Pipe
	.BYTE	232,005,320, 0
	.WORD	0
LD295:	.WORD	000700		; Object 09: Pipe
	.BYTE	070,005,320, 0
	.WORD	0
LD29C:	.WORD	000324		; Object 10: Pipe
	.BYTE	201,005,320, 0
	.WORD	0
LD2A3:	.WORD	000324		; Object 11: Granade
	.BYTE	145,006,322, 0
	.WORD	0
LD2AA:	.WORD	000324		; Object 12: BOMB
	.BYTE	146,010,326, 0
	.WORD	0
LD2B1:	.WORD	000324		; Object 13: Knife
	.BYTE	147,002,312, 0
	.WORD	0
LD2B8:	.WORD	000324		; Object ?? 14
	.BYTE	150,003,314, 0
	.WORD	0
LD2BF:	.WORD	000324		; Object 15: Pipe
	.BYTE	151,005,320, 0
	.WORD	0
LD2C6:	.WORD	000324		; Object 16: Pipe
	.BYTE	152,005,320, 0
	.WORD	0
LD2CD:	.WORD	000324		; Object 17: Pipe
	.BYTE	153,005,320, 0
	.WORD	0
LD2D4:	.WORD	000324		; Object ?? 18
	.BYTE	154,003,314, 0
	.WORD	0
LD2DB:	.WORD	000324		; Object 19: Knife
	.BYTE	155,002,312, 0
	.WORD	0
LD2E2:	.WORD	000324		; Object 20: Knife
	.BYTE	155,002,312, 0
	.WORD	0
LD2E9:	.WORD	000324		; Object ?? 21
	.BYTE	156,003,314, 0
	.WORD	0
LD2F0:	.WORD	000324		; Object 22: Knife
	.BYTE	157,002,312, 0
	.WORD	0
LD2F7:	.WORD	000324		; Object 23: Granade
	.BYTE	160,006,322, 0
	.WORD	0
LD2FE:	.WORD	000324		; Object 24: Knife
	.BYTE	161,002,312, 0
	.WORD	0
LD305:	.WORD	000324		; Object 25: Granade
	.BYTE	162,006,322, 0
	.WORD	0
LD30C:	.WORD	000324		; Object 26: Knife
	.BYTE	163,002,312, 0
	.WORD	0
LD313:	.WORD	000324		; Object ?? 27
	.BYTE	164,003,314, 0
	.WORD	0
LD31A:	.WORD	000324		; Object ?? 28
	.BYTE	165,003,314, 0
	.WORD	0
LD321:	.WORD	000324		; Object ?? 29
	.BYTE	166,003,314, 0
	.WORD	0
LD328:	.WORD	000324		; Object 30: Brick
	.BYTE	167,004,316, 0
	.WORD	0
LD32F:	.WORD	000324		; Object 31: Brick
	.BYTE	170,004,316, 0
	.WORD	0
LD336:	.WORD	000324		; Object 32: Brick
	.BYTE	171,004,316, 0
	.WORD	0
LD33D:	.WORD	000324		; Object 33: Brick
	.BYTE	172,004,316, 0
	.WORD	0
LD344:	.WORD	000324		; Object 34: Brick
	.BYTE	173,004,316, 0
	.WORD	0

; Table of objects, 35 records, 6 bytes each
LD34D:	.WORD	L9ED9, 000517		; Object L00
	.BYTE	201, 0
LD352:	.WORD	L9E22, 000614		; Object L01
	.BYTE	145, 0
LD357:	.WORD	L9E22, 000636		; Object L02: BOMB
	.BYTE	146, 0
LD35C:	.WORD	L990D, 000767		; Object L03
	.BYTE	147, 0
LD361:	.WORD	L8D5C, 000727		; Object L04
	.BYTE	150, 0
LD366:	.WORD	L8EE1, 000716		; Object L05
	.BYTE	151, 0
LD36B:	.WORD	L889F, 000514		; Object L06
	.BYTE	152, 0
LD370:	.WORD	L890E, 000411		; Object L07
	.BYTE	153, 0
LD375:	.WORD	L8CC8, 000762		; Object L08
	.BYTE	154, 0
LD37A:	.WORD	L8739, 000432		; Object L09
	.BYTE	155, 0
LD37F:	.WORD	L8799, 000707		; Object L10
	.BYTE	156, 0
LD384:	.WORD	L913F, 000762		; Object L11
	.BYTE	157, 0
LD389:	.WORD	L8321, 000747		; Object L12
	.BYTE	160, 0
LD38E:	.WORD	L8162, 000762		; Object L13
	.BYTE	161, 0
LD393:	.WORD	L7EF2, 000770		; Object L14
	.BYTE	162, 0
LD398:	.WORD	L7F48, 000664		; Object L15
	.BYTE	163, 0
LD39D:	.WORD	L7C6D, 000667		; Object L16
	.BYTE	164, 0
LD3A2:	.WORD	L7A9E, 000715		; Object L17
	.BYTE	165, 0
LD3A7:	.WORD	L7A9E, 000727		; Object L18
	.BYTE	166, 0
LD3AC:	.WORD	L7A9E, 000731		; Object L19
	.BYTE	167, 0
LD3B1:	.WORD	L7AF8, 000765		; Object L20
	.BYTE	170, 0
LD3B6:	.WORD	L7AF8, 000766		; Object L21
	.BYTE	171, 0
LD3BB:	.WORD	L9376, 000653		; Object L22
	.BYTE	172, 0
LD3C0:	.WORD	L79C6, 000765		; Object L23
	.BYTE	173, 0
LD3C5:	.WORD	L80F6, 000743		; Object L24: Console in room 80F6
	.BYTE	174, 0
LD3CA:	.WORD	L99A6, 000763		; Object L25: Console in room 99A6
	.BYTE	175, 0
LD3CF:	.WORD	L92A7, 000715		; Object L26: Console in room 92A7
	.BYTE	176, 0
LD3D4:	.WORD	L92EF, 000330		; Object L27: Console in room 92EF
	.BYTE	177, 0
LD3D9:	.WORD	L9005, 000445		; Object L28: Console in room 9005
	.BYTE	200, 0

; Find record for the current room in DE84 table
LDE68:
	;TODO
	RETURN

; Clear strings on the screen
LDEC1:
	;TODO
	RETURN	;STUB

LDEE6:	.ASCII	/                /	; String 18 spaces

TITLE:	.ASCII	/SABOTEUR 1 UKNC/
VERSIO:
.INCLUDE /VERSIO.MAC/
LDF27:	.ASCII	/S  START MISSION/

LC062:	.ASCII	/DISK RETRIEVED/
LC070:	.ASCII	/DISK /
LC075:	.ASCII	/BONUS: $05000/
LC082:	.ASCII	/LEVEL/
LC087:	.ASCII	/TOTAL PAY : $/

LE1EC:	.ASCII	/1/	; Current Level digit
	.EVEN

LDF37:
	;TODO

; Main menu
LDF60:	CALL	LDEC1			; Clear strings on the screen
	;TODO
	MOV	#15., R1
	MOV	#TITLE, R3
	MOV	#<SCRTOP+<1200*0.>+13.>, R2		;TODO
	CALL	LAED1			; Print string - title
	MOV	#17., R1
	MOV	#VERSIO, R3
	MOV	#<SCRTOP+<1200*2.>+13.>, R2		;TODO
	CALL	LAED1			; Print string - version
	MOV	#16., R1
	MOV	#LDF27, R3
	MOV	#<SCRTOP+<1200*10.>+13.>, R2		;TODO
	CALL	LAED1			; Print string "S START MISSION"
	MOV	#LC082, R3		; "LEVEL"
	MOV	#5., R1
	MOV	#<SCRTOP+<1200*12.>+16.>, R2		;TODO
	CALL	LAED1			; Print string "LEVEL"
	MOV	#LE1EC, R3
	INC	R1			; 1 char
	INC	R2
	CALL	LAED1			; Print level digit

	;TODO
	CALL	WTKEY ;DEBUG
	BR	LE2A7 ;DEBUG		; => Start Mission

	JMP	LBC3B

; Start Mission
LE2A7:
	;TODO

	MOVB	#TIMERI, LB5C4		; set initial value for the fast timer

	BR	LF913


LF913:
	;TODO
	JMP	LB3B0


; Room 84A8 initialization
LF973:
;NOTE: Crane sprite copying moved into room sequence
	JMP	LB422

; Sound ??
LF9A1:
	;TODO
	RETURN

; Pause, then wait for any key pressed
LF9B9:
	;TODO
	CALL	WTKEY ;DEBUG
	RETURN	;STUB

LF9F9:	MOV	#264, R3		; $00B4
	MOV	#1, R1
	CALL	LFA11
	MOV	#LBDAF, R3		; Ninja standing
	RETURN

LFA11:
	;TODO
	RETURN	;STUB

LFA31:	CALL	L9DD9			; Decrease Energy by R1
	MOV	#1, R0
	CALL	LF9A1			; Sound
	RETURN

;------------------------------------------------------------------------------

.INCLUDE /S1SPRT.MAC/
	.EVEN

.INCLUDE /S1TILE.MAC/
	.EVEN

;------------------------------------------------------------------------------

; Tile screen 0 30x17 tiles, 510 bytes - background
L6590:	.BLKB	510.
; Tile screen 1 30x17 tiles, 510 bytes - update flags
L678E:	.BLKB	510.
; Tile screen 2 30x17 tiles, 510 bytes - Ninja screen
L698C:	.BLKB	510.
; Tile screen 3 30x17 tiles, 510 bytes - Dog screen
L6B8A:	.BLKB	510.
; Tile screen 4 30x17 tiles, 510 bytes - Guard screen
L6D88:	.BLKB	510.
; Tile screen 5 30x17 tiles, 510 bytes - front
L6F86:	.BLKB	510.

;------------------------------------------------------------------------------
	.END	STCORE
