	.TITLE	SABOT1
	.ASECT


;------------------------------------------------------------------------------

; PPUKEY bits
PKEYRT =: 001	; RIGHT
PKEYLT =: 002	; LEFT
PKEYDN =: 004	; DOWN
PKEYUP =: 010	; UP
PKEYFR =: 020	; FIRE key
PKEYST =: 200	; STOP key

PPUCOM = 1000 - 2
PPUADR = 1000 - 4
PPUDAT = 1000 - 6
PPUKEY = 1000 - 10

;------------------------------------------------------------------------------

	.=001000
START::
	CLR	@#177560
	MTPS	#000340			; Disable interrupts
	MOV	SP, OSTACK		; Save initial SP address
;
	CALL	STPAL			; Set up the game palette
	MOV	#GAMESC, R1		; String for game screen preparing
	CALL	PRINT
	CALL	PAUSE			; wait while screen updates
;
K01220:	JMP	LBC0D			; => title picture and Menu
;
OSTACK:	.WORD	01000			; Saved initial SP
;
FNCORE:	CALL	STPALD			; Select default palette
	MOV	OSTACK, SP
	MOV	#EXITSC, R1		; String for screen cleanup before the exit
	CALL	PRINT
	EMT	350			; .EXIT
;
;------------------------------------------------------------------------------

; Procedure: Print string: R1 = string address, string ends with zero; utilizes R0
PRINT:
10$:	MOVB	(R1)+, R0		; End of line?
	BEQ	RETN			; yes => exit
20$:	TSTB	@#177564		; Channel 0 source ready?
	BPL	20$			; no => wait
	MOV	R0, @#177566		; send symbol into Channel 0
	BR	10$

; Procedure: Pause after screen cleanup, so PPU will finish the work
PAUSE:	; Pause to let PPU finish the previous commands
	MOV	#177777, R5
1$:	NOP
	SOB	R5, 1$
RETN:	RETURN

; Procedure: Clear key buffer
WAITUP:	TSTB	@#177560
	BPL	RETN
	MOVB	@#177562, R0
	BR	WAITUP

; Procedure: Wait for a key from the keyboard: R0 = key received
WTKEY:	TSTB	@#177560
	BPL	WTKEY
	CLR	R0
	MOVB	@#177562, R0		; symbol to R0
	CMPB	R0, #33
	BNE	RETN
ESCKEY:	TSTB	@#177560
	BPL	ESCKEY
	MOVB	@#177562, R0		; symbol to R0
	BIS	#15400,R0		; #33 to higher byte
	RETURN
; Procedure: Receive a symbol from keyboard: flag Z=0 = have a symbol, R0 = key received
GETKEY:	TSTB	@#177560		; have a symbol?
	BPL	10$			; nothing => exiting
	MOVB	@#177562, R0		; symbol to R0
	CMPB	R0, #33			; Esc ?
	BEQ	ESCKEY
	RETURN
10$:	CLR	R0			; return zero for key received
	RETURN

; Procedure: Clear screen with Blue color, for Menu screen
CLSRNM:	MOV	#377, @#<CLSRN+2>
	BR	CLSRN

; Procedure: Clear screen with Black color, for Game screen
CLSRNB:	CLR	@#<CLSRN+2>

CLSRN:	MOV	#377, R0		; Blue color filler
	MOV	#SCREEN + 2, @#176640
	MOV	#208., R4
10$:	MOV	#36., R1
20$:	MOV	R0, @#176642
	INC	@#176640
	SOB	R1, 20$
	ADD	#<120-36.>, @#176640
	SOB	R4, 10$
	RETURN

GAMESC:	; String for game screen preparing
	.BYTE	33,246,62		; Screen format 40x24
	.BYTE	33,240,63		; Ink color
	.BYTE	33,241,60		; Place color
	.BYTE	33,242,60		; Back color
	.BYTE	14			; Clear screen
	.BYTE	33,247,60		; Cursor color
	.BYTE	033,131,61,40		; Cursor position
	.BYTE	0
EXITSC:	; String for screen cleanup before the exit
	.BYTE	33,246,061		; Screen format 80x24
	.BYTE	33,240,67		; Ink color
	.BYTE	33,241,61		; Place color 1
	.BYTE	33,242,61		; Back color 1
	.BYTE	33,247,67		; Cursor color
	.BYTE	14			; Clear screen
	.BYTE	0

	.EVEN

;------------------------------------------------------------------------------

; Channel 2 data
PPMSG:	.WORD	PPARR
        .WORD	177777
PPARR:	.BYTE	0			; return value (0 - OK)
PPCMD:	.BYTE	1			; command (1 - allocate)
	.WORD	32			; device type (32 = PPU mem)
PPAPP:	.WORD	0			; argument(s) (PPU addr for mem operations)
PPACP:	.WORD	<PPEND-PPSTA>/2		; CPU addr (length in words for mem allocate)
PPLEN:	.WORD	<PPEND-PPSTA>/2		; length in words

; Send to PPU by Channel 2
PPSen:	MOV	#PPMSG, R2
	MOV	#5, R3
	BR	20$
10$:	MOVB	(R2)+, @#176676
20$:	TSTB	@#176674
	BPL	20$
	SOB	R3, 10$
	RETURN

; Prepare and run PPU code block
RUNPPU:
	MOV	#177777, PPUCOM
	CLR	PPUDAT
	CLR	PPUKEY
;
	CALL	PPSEN			; allocate (!) no testing for success
	MOV	PPAPP, PPUADR		; copy allocated PPU addr for later use
	MOVB	#20, PPCMD		; set command to copy memory CPU -> PPU
	MOV	#PPSTA, PPACP		; adjust start addr (there was mem size for allocate)
	CALL	PPSEN
	MOVB	#30, PPCMD		; set command to run the PPU code
	CALL	PPSEN
;
	TST	PPUCOM
	BNE	.-4
	CLR	R0
	SOB	R0, .			; wait a bit
	RETURN

;------------------------------------------------------------------------------

; Start of PPU code block
PPSTA:
	MTPS	#200
; stop FDD (do we need that?)
	CLR	R0
	CALL	@7132(R0)
; backup and clean low addrs except 272
	MOV	PC, R0
	ADD	#BKP-., R0
	CLR	R1
	MOV	#400, R3
10$:	MOV	(R1), (R0)+
	CMP	R1, #272
	BNE	20$
	TST	(R1)+
	BR	30$
20$:	CLR	(R1)+
30$:	SOB	R3, 10$
	MOV	#2, (R3)		; set RTI at @#0

; setup other
	;MOV	@#177054, BKP054
; timers
	BIC	#^B0000001000000000, @#177054	; enable vsync in CPU
	BIC	#^B0000000100000000, @#177054	; enable vsync in PPU
	BIC	#^B0001111110000000, @#177716	; sound init (mixer off)
	MOV	#200, @#306			; PSW for PPU timer interrupt
; keyboard
	MOV	PC, R0
	ADD	#KEYINT-., R0
	MOV	R0, @#300
	BIS	#100, @#177700		; allow keyboard interrupts
; vsync
	MOV	PC, R0
	ADD	#VSYINT-., R0
	MOV	R0, @#100
	MOV	#200, @#102
; Done
	MTPS	#0
	MOV	#<PPUCOM/2>, @#177010	; ackn of command execution
	CLR	@#177014

PMAIN:	MOV	#<PPUCOM/2>, @#177010	; get command from CPU
	MOV	@#177014, R0
	BEQ	PMAIN			; no command
	;BMI	Exit			; exit PPU command
	ASL	R0
	ASL	R0
	ADD	R0, PC
	JMP	PMAIN			; 0
	;TODO

; Keyboard interrupt handler
KEYINT:	MOV	@#177010, -(SP)
	MOV	R0, -(SP)
	MOV	#<PPUKEY/2>, @#177010	; prepare addr of keys in CPU
	MOVB	@#177702, R0		; scancode (read it just once)
	BMI	50$
; key pressed
	CMP	R0, #116		; C_KEY_LEFT
	BNE	11$
	BIS	#PKEYLT, @#177014
	BR	90$
11$:	CMP	R0, #133		; C_KEY_RIGHT
	BNE	12$
	BIS	#PKEYRT, @#177014
	BR	90$
12$:	CMP	R0, #154		; C_KEY_UP
	BNE	13$
	BIS	#PKEYUP, @#177014
	BR	90$
13$:	CMP	R0, #134		; C_KEY_DOWN
	BNE	14$
	BIS	#PKEYDN, @#177014
	BR	90$
14$:	CMP	R0, #105		; C_KEY_SHIFT
	BNE	15$
	BIS	#PKEYFR, @#177014
	BR	90$
15$:	CMP	R0, #200		; C_KEY_STOP
	BNE	90$
	BIS	#PKEYST, @#177014
	BR	90$
; key released
50$:	BIC	#^B1111111111110000, R0
	CMP	R0, #^B1110		; left
	BNE	51$
	BIC	#PKEYLT, @#177014
	BR	90$
51$:	CMP	R0, #^B1011		; right
	BNE	52$
	BIC	#PKEYRT, @#177014
	BR	90$
52$:	CMP	R0, #^B1100		; up down
	BNE	53$
	BIC	#<PKEYUP+PKEYDN>, @#177014
	BR	90$
53$:	CMP	R0, #^B0101		; shift
	BNE	90$
	BIC	#PKEYFR, @#177014
; exit interrupt
90$:	MOV	(SP)+, R0
	MOV	(SP)+, @#177010
	RTI

VSYINT:
	RTI

BKP:	.BLKW	400			; 0-1000 addrs backup

PPEND:	; End of PPU code block

;------------------------------------------------------------------------------

PALNO:	.WORD	0		; Current palette number
; Palette to set up in the PPU memory
;		 |____....____....|
PALETD:	.WORD	^B1011101010011000	; Default UKNC palette
	.WORD	^B1111111011011100	;
PALETT:	.WORD	^B1010100111000000	; Game palette 0 - for GRB
	.WORD	^B1100110011011010	;   black / blue / red / green
	.WORD	^B1010100111010000	; Game palette 1 - for RGB
	.WORD	^B1010101011011100	;   black / blue / green / red
	.WORD	^B1011111110011001	; Game palette 2
	.WORD	^B1111111111011100	;   black on blue
	.WORD	^B0100000001101111	; Game palette 3
	.WORD	^B0000001100100001	;   black on white

; Parameters block used to exchange with PPU using Channel 2
PPBLCK:	.BYTE	0		; This byte will have error code or zero
PPBCMD:	.BYTE	20		; Command (01-get memory, 02-free memory 10-read, 20-write, 30-start)
	.WORD	32		; Device - PPU
PPBAPP:	.WORD	002470		; Address in PPU RAM - two words for the new palette
PPBACP:	.WORD	PALETT		; Address in PPU RAM - address for the palette
	.WORD	2		; Block length in bytes
PPBADR:	.WORD	PPBLCK		; Start address of the parameters block
	.WORD	401		; Stop element (used in the exchange)

; Restore the default palette
STPALD:
	MOV	#PALETD, R0
	BR	STPAL1
; Set up the palette
STPAL:	MOV	@#PALNO, R0
	BIC	#177774, R0		; 0..3
	ASL	R0
	ASL	R0			; x4
	ADD	#PALETT, R0
STPAL1:	MOV	R0, @#PPBACP
;	BR	PPSEND
; Procedure used to send parameters block for PPU using Channel 2
PPSEND:	MOV	#PPBADR, R0
	MOV	#5, R1
	MTPS	#200
	BR	1$
2$:	MOVB	(R0)+, @#176676
1$:	TSTB	@#176674
	BPL	1$
	SOB	R1, 2$
	MTPS	#0
	RETURN

;------------------------------------------------------------------------------

.INCLUDE /S1CORE.MAC/

STACK::	.BLKW	20

;------------------------------------------------------------------------------
	.END	START
