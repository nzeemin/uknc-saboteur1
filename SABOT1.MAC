	.TITLE	SABOT1
	.ASECT

;------------------------------------------------------------------------------

; Set PPU command
.MACRO	PPUCMD	X
	MOV	X, @#PPUCOM
.ENDM
; Set PPU command and wait for acknowledgement
.MACRO	PPUCMW	X
	MOV	X, @#PPUCOM
	TST	@#PPUCOM
	BNE	.-4
.ENDM

;------------------------------------------------------------------------------

SCREEN = 100000		; Screen start, indirect address for UKNC
SCRTOP = SCREEN + 1200 + 4	; Where the game screen starts
SCRIND = SCRTOP + <1200*19.>	; Screen address for first indicators line

; PPUKEY bits
PKEYRT =: 001	; RIGHT
PKEYLT =: 002	; LEFT
PKEYDN =: 004	; DOWN
PKEYUP =: 010	; UP
PKEYFR =: 020	; FIRE key
PKEYST =: 200	; STOP key

PPUCOM = 1000 - 2	; PPU/CPU command and acknowledge
PPUADR = 1000 - 4	; allocated PPU address
PPUDAT = 1000 - 6
PPUKEY = 1000 - 10

TLBUFS = 30.	; Tile buffer size

;------------------------------------------------------------------------------

	.=001000
START::
	CLR	@#177560
	MTPS	#000340			; Disable interrupts
	MOV	SP, OSTACK		; Save initial SP address
;
	CALL	STPAL			; Set up the game palette
	MOV	#GAMESC, R1		; String for game screen preparing
	CALL	PRINT
	CALL	PAUSE			; wait while screen updates
;
	JMP	LBC0D			; => title picture and Menu
;
OSTACK:	.WORD	01000			; Saved initial SP
;
FNCORE:	CALL	STPALD			; Select default palette
	MOV	OSTACK, SP
	MOV	#EXITSC, R1		; String for screen cleanup before the exit
	CALL	PRINT
	EMT	350			; .EXIT
;
;------------------------------------------------------------------------------

; Procedure: Print string: R1 = string address, string ends with zero; utilizes R0
PRINT:
10$:	MOVB	(R1)+, R0		; End of line?
	BEQ	RETN			; yes => exit
20$:	TSTB	@#177564		; Channel 0 source ready?
	BPL	20$			; no => wait
	MOV	R0, @#177566		; send symbol into Channel 0
	BR	10$

; Procedure: Pause after screen cleanup, so PPU will finish the work
PAUSE:	; Pause to let PPU finish the previous commands
	MOV	#177777, R5
1$:	NOP
	SOB	R5, 1$
RETN:	RETURN

; Procedure: Clear key buffer
WAITUP:	TSTB	@#177560
	BPL	RETN
	MOVB	@#177562, R0
	BR	WAITUP

; Procedure: Wait for a key from the keyboard: R0 = key received
WTKEY:	TSTB	@#177560
	BPL	WTKEY
	CLR	R0
	MOVB	@#177562, R0		; symbol to R0
	CMPB	R0, #33
	BNE	RETN
ESCKEY:	TSTB	@#177560
	BPL	ESCKEY
	MOVB	@#177562, R0		; symbol to R0
	BIS	#15400,R0		; #33 to higher byte
	RETURN
; Procedure: Receive a symbol from keyboard: flag Z=0 = have a symbol, R0 = key received
GETKEY:	TSTB	@#177560		; have a symbol?
	BPL	10$			; nothing => exiting
	MOVB	@#177562, R0		; symbol to R0
	CMPB	R0, #33			; Esc ?
	BEQ	ESCKEY
	RETURN
10$:	CLR	R0			; return zero for key received
	RETURN

; Procedure: Clear screen with Blue color, for Menu screen
CLSRNM:	MOV	#377, @#<CLSRN+2>
	BR	CLSRN

; Procedure: Clear screen with Black color, for Game screen
CLSRNB:	CLR	@#<CLSRN+2>

CLSRN:	MOV	#377, R0		; Blue color filler
	MOV	#SCREEN + 2, @#176640
	MOV	#208., R4
10$:	MOV	#36., R1
20$:	MOV	R0, @#176642
	INC	@#176640
	SOB	R1, 20$
	ADD	#<120-36.>, @#176640
	SOB	R4, 10$
	RETURN

GAMESC:	; String for game screen preparing
	.BYTE	33,246,62		; Screen format 40x24
	.BYTE	33,240,63		; Ink color
	.BYTE	33,241,60		; Place color
	.BYTE	33,242,60		; Back color
	.BYTE	14			; Clear screen
	.BYTE	33,247,60		; Cursor color
	.BYTE	033,131,61,40		; Cursor position
	.BYTE	0
EXITSC:	; String for screen cleanup before the exit
	.BYTE	33,246,061		; Screen format 80x24
	.BYTE	33,240,67		; Ink color
	.BYTE	33,241,61		; Place color 1
	.BYTE	33,242,61		; Back color 1
	.BYTE	33,247,67		; Cursor color
	.BYTE	14			; Clear screen
	.BYTE	0

	.EVEN

;------------------------------------------------------------------------------

; Channel 2 data
PPMSG:	.WORD	PPARR
        .WORD	177777
PPARR:	.BYTE	0			; return value (0 - OK)
PPCMD:	.BYTE	1			; command (1 - allocate)
	.WORD	32			; device type (32 = PPU mem)
PPAPP:	.WORD	0			; argument(s) (PPU addr for mem operations)
PPACP:	.WORD	<PPEND-PPSTA>/2		; CPU addr (length in words for mem allocate)
PPLEN:	.WORD	<PPEND-PPSTA>/2		; length in words

; Send to PPU by Channel 2
PPSen:	MOV	#PPMSG, R2
	MOV	#5, R3
	BR	20$
10$:	MOVB	(R2)+, @#176676
20$:	TSTB	@#176674
	BPL	20$
	SOB	R3, 10$
	RETURN

; Prepare and run PPU code block
RUNPPU:
	MOV	#177777, PPUCOM
	CLR	PPUDAT
	CLR	PPUKEY
;
	CALL	PPSEN			; allocate (!) no testing for success
	MOV	PPAPP, PPUADR		; copy allocated PPU addr for later use
	MOVB	#20, PPCMD		; set command to copy memory CPU -> PPU
	MOV	#PPSTA, PPACP		; adjust start addr (there was mem size for allocate)
	CALL	PPSEN
	MOVB	#30, PPCMD		; set command to run the PPU code
	CALL	PPSEN
;
	TST	PPUCOM
	BNE	.-4
	CLR	R0
	SOB	R0, .			; wait a bit
	RETURN

; Stop PPU procedure and remove the code
STOPPU:	PPUCMW	#177777			; command PPU to exit
; free PPU memory
	MOVB	#2, PPCMD		; set command to free PP memory
	MOV	PPUADR, PPAPP
	CALL	PPSEN
;
	CLR	PPUKEY
	RETURN

;==============================================================================
; PPU code block

PPSTA:
	MTPS	#200
; stop FDD (do we need that?)
	CLR	R0
	CALL	@7132(R0)
; backup and clean low addrs except 272
	MOV	PC, R0
	ADD	#BKP-., R0
	CLR	R1
	MOV	#400, R3
10$:	MOV	(R1), (R0)+
	CMP	R1, #272
	BNE	20$
	TST	(R1)+
	BR	30$
20$:	CLR	(R1)+
30$:	SOB	R3, 10$
	MOV	#2, (R3)		; set RTI at @#0

; setup other
	MOV	@#177054, BKP054
; timers
	BIC	#^B0000001000000000, @#177054	; enable vsync in CPU
	BIC	#^B0000000100000000, @#177054	; enable vsync in PPU
	BIC	#^B0001111110000000, @#177716	; sound init (mixer off)
	MOV	#200, @#306			; PSW for PPU timer interrupt
; keyboard
	MOV	PC, R0
	ADD	#KEYINT-., R0
	MOV	R0, @#300
	BIS	#100, @#177700		; allow keyboard interrupts
; vsync
	MOV	PC, R0
	ADD	#VSYINT-., R0
	MOV	R0, @#100
	MOV	#200, @#102
PDONE:
	MTPS	#0
	MOV	#<PPUCOM/2>, @#177010	; ackn of command execution
	CLR	@#177014
; Main loop of the PPU procedure
PMAIN:	CALL	DRTILS			; draw tiles
	MOV	#<PPUCOM/2>, @#177010	; get command from CPU
	MOV	@#177014, R0
	BMI	PEXIT			; exit PPU command
	ASL	R0
	ASL	R0
	ADD	R0, PC
	JMP	PMAIN			; 0 - no command
	JMP	PSOUND			; 1 - play sound 1
	;TODO
; Exit command
PEXIT:	MTPS	#200
; restore block 0..1000
	MOV	PC, R0
	ADD	#BKP-., R0
	CLR	R1
	MOV	#400, R3
	MOV	(R0)+, (R1)+
	SOB	R3, .-2
	MOV	BKP054, @#177054
; signal to CPU: we're finished
	MOV	#PPUCOM/2, @#177010
	CLR	@#177014
	MTPS	#0
	RETURN

; Keyboard interrupt handler
KEYINT:	MOV	@#177010, -(SP)
	MOV	R0, -(SP)
	MOV	#<PPUKEY/2>, @#177010	; prepare addr of keys in CPU
	MOVB	@#177702, R0		; scancode (read it just once)
	BMI	50$
; key pressed
	CMP	R0, #116		; C_KEY_LEFT
	BNE	11$
	BIS	#PKEYLT, @#177014
	BR	90$
11$:	CMP	R0, #133		; C_KEY_RIGHT
	BNE	12$
	BIS	#PKEYRT, @#177014
	BR	90$
12$:	CMP	R0, #154		; C_KEY_UP
	BNE	13$
	BIS	#PKEYUP, @#177014
	BR	90$
13$:	CMP	R0, #134		; C_KEY_DOWN
	BNE	14$
	BIS	#PKEYDN, @#177014
	BR	90$
14$:	CMP	R0, #105		; C_KEY_SHIFT
	BNE	15$
	BIS	#PKEYFR, @#177014
	BR	90$
15$:	CMP	R0, #4			; C_KEY_STOP
	BNE	90$
	BIS	#PKEYST, @#177014
	BR	90$
; key released
50$:	BIC	#^B1111111111110000, R0
	CMP	R0, #^B1110		; left
	BNE	51$
	BIC	#PKEYLT, @#177014
	BR	90$
51$:	CMP	R0, #^B1011		; right
	BNE	52$
	BIC	#PKEYRT, @#177014
	BR	90$
52$:	CMP	R0, #^B1100		; up down
	BNE	53$
	BIC	#<PKEYUP+PKEYDN>, @#177014
	BR	90$
53$:	CMP	R0, #^B0101		; shift
	BNE	90$
	BIC	#PKEYFR, @#177014
; exit interrupt
90$:	MOV	(SP)+, R0
	MOV	(SP)+, @#177010
	RTI

; Draw tiles
DRTILS:
	MOV	#<TILBUF/2>, R0
	MOV	R0, -(SP)		; PUSH TILBUF/2
	MOV	PC, -(SP)
	ADD	#TMPBUF-., (SP)		; (SP) = temp buffer addr
	MOV	#177010, R4		; mem index
	MOV	#177014, R5		; mem data
	MOV	#177024, R3		; pix data
	MOV	#TLBUFS, <91$+2>	; tiles max
10$:
	MOV	2(SP), (R4)		; TILBUF/2
	MOV	(R5), R1		; get screen address
	BEQ	90$			; nothing to draw =>
; Copy tile data 8. bytes to temp buffer
	MOV	(SP), R2
	INC	(R4)			; skip screen address
	.REPT	4
	MOV	(R5), R0
	MOV	R0, (R2)+
	SWAB	R0
	MOV	R0, (R2)+
	INC	(R4)
	.ENDR
; Convert and set colors
	MOV	(R5), R0		; get attribute
	MOV	R0, @#177016		; set INK color
	ASR	R0
	BIC	#^B1111111111100011, R0
	ADD	PC, R0
	ADD	#COLTBL-., R0
	MOV	(R0)+, @#177020		; set PAPER color
	MOV	(R0)+, @#177022
	MOV	R1, (R4)		; set screen address
; Copy temp buffer to screen
	MOV	(SP), R2
	MOV	#120, R1		; screen line offset
	.REPT	8.
	MOV	(R2)+, (R3)
	ADD	R1, (R4)
	.ENDR
; Mark the record as drawn
	MOV	2(SP), (R4)
	CLR	(R5)
90$:	ADD	#6, 2(SP)		; next record
91$:	DEC	#TLBUFS			; !!MUT-ARG!! counter here
	BNE	10$			; continue loop
	TST	(SP)+
	TST	(SP)+			; empty stack
	RETURN

VSYINT:
	RTI

SNDADR:	.WORD	0

; Start to play sound; R0 = sound number multiplied by 4
PSOUND:	;CALL	TIMRIN
	;ASR	R0			; divide by 2
	;ADD	PC, R0
	;ADD	#SNDTAB-., R0
	;ADD	(R0), R0
	;BEQ	99$
	;MOV	(R0)+, R1
	;BEQ	99$
	;MOV	R0, SNDADR
	;MOV	R1, @#177712		; load counter
	;TST	@#177714
	;TST	@#177714
	;BIC	#200, @#177716		; sound to LO
	;MOV	PC, R0
	;ADD	#SNINTH+2-., R0		; set sound interrupt to HI
	;MOV	R0, @#304
	;MOV	#^B01000111, @#177710	; allow int, start, timer = (..FFS) FF = 00 - 2mks, 01 - 4mks, 10 - 8mks, 11 - 16mks
99$:	JMP	PDONE			; return to PPU main loop

; sound timer interrupt (LO)
SNINTL:	MOV	R0, -(SP)
	BIC	#200, @#177716
	MOV	PC, R0
	ADD	#SNINTH+2-., R0
	MOV	R0, @#304
	BR	SNINTN
; sound timer interrupt (HI)
SNINTH:	MOV	R0, -(SP)
	BIS	#200, @#177716
	MOV	PC, R0
	ADD	#SNINTL+2-., R0
	MOV	R0, @#304
;
SNINTN:	MOV	(SP)+, R0
	MOV	@SNDADR, @#177712	; update timer
	BEQ	90$			; end of sound?
	ADD	#2, SNDADR
	TST	@#177714
	TST	@#177714
	RTI
90$:	CLR	@#177710		; stop timer and ints
	TST	@#177714
	TST	@#177714
	RTI

; timer init (stop, clear counter)
TIMRIN:
	CLR	@#177710		; clear control, stop
	CLR	@#177712		; clear buffer
	TST	@#177714
	TST	@#177714
	RETURN

SNDTAB:	.WORD	0			; stub for sound 0
	.WORD	SND001-.		; 1
;
	.RADIX	10
; Sound: punch/hit
SND001:	.WORD	30,30, 30,30, 20,20
	.WORD	0
	.RADIX	8

; Color conversion table
COLTBL:	.WORD	^B0000000000000000, ^B0000000000000000
	.WORD	^B0001000100010001, ^B0001000100010001
	.WORD	^B0010001000100010, ^B0010001000100010
	.WORD	^B0011001100110011, ^B0011001100110011
	.WORD	^B0100010001000100, ^B0100010001000100
	.WORD	^B0101010101010101, ^B0101010101010101
	.WORD	^B0110011001100110, ^B0110011001100110
	.WORD	^B0111011101110111, ^B0111011101110111

TMPBUF:	.BLKW	8.			; Temp buffer for tile drawing
BKP054:	.WORD	0			; Saved 177054
BKP:	.BLKW	400			; 0-1000 addrs backup

PPEND:
; End of PPU code block
;==============================================================================

PALNO:	.WORD	0		; Current palette number
; Palette to set up in the PPU memory
;		 |____....____....|
PALETD:	.WORD	^B1011101010011000	; Default UKNC palette
	.WORD	^B1111111011011100	;
PALETT:	.WORD	^B1011101010011000	; Game palette 0 - for GRB
	.WORD	^B1111111011011100	;   black / blue / red / green
	.WORD	^B1010100111010000	; Game palette 1 - for RGB
	.WORD	^B1010101011011100	;   black / blue / green / red
	.WORD	^B1011111110011001	; Game palette 2
	.WORD	^B1111111111011100	;   black on blue
	.WORD	^B0100000001101111	; Game palette 3
	.WORD	^B0000001100100001	;   black on white

; Parameters block used to exchange with PPU using Channel 2
PPBLCK:	.BYTE	0		; This byte will have error code or zero
PPBCMD:	.BYTE	20		; Command (01-get memory, 02-free memory 10-read, 20-write, 30-start)
	.WORD	32		; Device - PPU
PPBAPP:	.WORD	002470		; Address in PPU RAM - two words for the new palette
PPBACP:	.WORD	PALETT		; Address in PPU RAM - address for the palette
	.WORD	2		; Block length in bytes
PPBADR:	.WORD	PPBLCK		; Start address of the parameters block
	.WORD	401		; Stop element (used in the exchange)

; Restore the default palette
STPALD:
	MOV	#PALETD, R0
	BR	STPAL1
; Set up the palette
STPAL:	MOV	@#PALNO, R0
	BIC	#177774, R0		; 0..3
	ASL	R0
	ASL	R0			; x4
	ADD	#PALETT, R0
STPAL1:	MOV	R0, @#PPBACP
;	BR	PPSEND
; Procedure used to send parameters block for PPU using Channel 2
PPSEND:	MOV	#PPBADR, R0
	MOV	#5, R1
	MTPS	#200
	BR	1$
2$:	MOVB	(R0)+, @#176676
1$:	TSTB	@#176674
	BPL	1$
	SOB	R1, 2$
	MTPS	#0
	RETURN

;------------------------------------------------------------------------------

STARTC::
.INCLUDE /S1CORE.MAC/

STACK::	.BLKW	20

;------------------------------------------------------------------------------
	.END	START
